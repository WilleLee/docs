# UI 기술하기

## 첫 컴포넌트

리액트 어플리케이션의 각각이 고립된 UI 조각인 컴포넌트들로 이루어진다. 리액트 컴포넌트는 **마크업과 함께 뿌려지는 자바스크립트 함수**이다.

### 컴포넌트: 블록을 형성하는 UI

리액트는 HTML 마크업, CSS, 자바스크립트를 커스텀 컴포넌트들, 즉 재사용 가능한 UI 요소들로 합칠 수 있도록 돕는다. 이로써 프로젝트가 거대해질수록 다양한 디자인 요소들을 사전에 작성한 컴포넌트들로 구성하여 개발 시간을 획기적으로 단축하게 된다.

### 컴포넌트 정의하기

- 스텝 1: 컴포넌트를 export한다.
- 스텝 2: 함수를 정의한다.
- 스텝 3: 마크업을 추가한다. (JSX 문법을 이용하면 자바스크립테 마크업 언어를 삽입할 수 있다.)

### 컴포넌트 네스팅 및 조직화

컴포넌트는 일반적인 자바스크립트 함수이므로 하나의 파일에 다수의 컴포넌트를 위치시킬 수 있다. 이는 컴포넌트가 상대적으로 작거나 서로 밀접하게 관련되어 있는 경우 유용하다. 물론 파일에 너무 많은 컴포넌트가 자리하게 되면 언제든지 특정 컴포넌트를 다른 파일로 분리시킬 수 있다.

가령 Profile 컴포넌트가 Gallery 컴포넌트 안에서 렌더링된다면, Gallery 컴포넌트를 부모 컴포넌트라고 하고, 그 안에서 렌더링 되는 각각의 Profile 컴포넌트는 자식 컴포넌트가 된다. 이처럼 리액트에서는 컴포넌트를 한 번 정의한 후 여러 장소에서 원하는 만큼 재사용할 수 있다.

## 컴포넌트의 import 및 export

- 스텝 1: 컴포넌트를 정의할 새로운 자바스크립트 파일을 만든다.
- 스텝 2: 해당 파일로부터 함수 컴포넌트를 export 한다.
- 스텝 3: 이 컴포넌트를 사용할 파일에서 import 한다.

## JSX로 마크업 작성하기

수 년 간 웹 개발자들은 컨텐츠는 HTML로, 디자인은 CSS로, 로직은 자바스크립트로, 각각 분리된 파일에 작성해왔다. 어플리케이션의 컨텐츠가 HTML로 마크업되는 한편 페이지의 로직은 자바스크립트 코드로 분리되어 존재한 것이다.

하지만 웹의 상호작용성이 중요해지면서 로직이 컨텐츠를 결정해야 하는 경우가 많아졌다. 이것이 리액트에서 컴포넌트라고 하는 동일한 공간에 렌더링 로직과 마크업을 함께 작성하는 이유이다.

### JSX 규칙

1. 단 하나의 루트 요소만을 반환하라.
2. 모든 태그들을 닫아라. e.g. `<img />`
3. 대부분의 속성을 camelCase로 작성하라.

## 중괄호를 이용한 자바스크립트 표현식 삽입

JSX는 HTML과 유사한 마크업을 자바스크립트 파일 내에 작성하도록 하여 렌더링 로직과 컨텐츠를 동일한 공간에 둘 수 있도록 한다. 물론 그러한 마크업 내부에 약간의 자바스크립트 로직을 추가하거나 동적인 속성을 참조해야 하는 경우가 있을텐데, 이때는 JSX에서 중괄호를 사용하면 된다.

### 따옴표로 문자열 전달하기

문자열 속성을 JSX에 전달하고자 한다면 작은 따옴표나 큰 따옴표로 이를 감싸면 된다.

```javascript
export default function Avatar() {
  return (
    <img
      className="avatar"
      src=“blahblah.com/avatars/123.png“
      alt=“awesome picture”
    />
  );
}
```

그러나 가령 src나 alt로 전달할 문자를 동적으로 정의하고자 한다면, **따옴표를 중괄호로 대체하여 자바스크립트 값을 이용**하도록 하면 된다.

```javascript
export default function Avatar() {
  const avatar = “blahblah.com/avatars/123.png“;
  const description = “awesome picture”;
  return (
    <img
      className="avatar"
      src={avatar}
      alt={description}
    />
  );
}
```

### 중괄호 사용하기: 자바스크립트 세계로

JSX에서는 중괄호를 이용해 그 안에서 자바스크립트를 이용할 수 있다. 아래 예시에서는 `name`이라는 변수에 이름 하나를 먼저 선언하고, 이를 `<h1>` 태그 안에서 중괄호로 임베드한다.

```javascript
export default function TodoList() {
  const name = “Wille Lee”;
  return (
    <h1>{name}'s To Do List</h1>
  );
}
```

> **어떤 경우에 중괄호를 사용하는가?**  
> JSX에서는 두 가지 경우에서만 중괄호를 사용할 수 있다.
>
> 1. JSX 태그 바로 아래에 텍스트로 삽입. e.g. `<h1>{name}</h1>`은 가능하지만, `<{tag}>Wille</ {tag}>`은 불가능하다.
> 2. `=` 표시 바로 뒤에 속성으로 삽입. e.g. `src={avatar}`

### 중복 중괄호 사용하기: CSS를 포함한 객체의 전달

JSX에서는 문자열, 숫자 등 뿐만 아니라 객체 또한 전달할 수 있다. 이 경우 반드시 객체를 또 하나의 중괄호로 감싸야만 한다. e.g. `person={{ name: “Wille”, age: 29 }}`

## 컴포넌트로 props 전달하기

리액트 컴포넌트들은 서로 소통하기 위해 props를 사용한다. 모든 부모 컴포넌트는 props 전달을 통해 자식 컴포넌트로 특정 정보를 보낼 수 있다. 이때 props로는 객체, 배열, 함수를 포함한 모든 자바스크립트 값이 전달될 수 있다.

### 익숙한 props

props는 JSX 태그로 보내는 정보이다. 예를 들어 className, src, alt, width, height 등은 `<img />` 태그로 보낼 수 있는 props이다. ReactDOM은 HTML 표준을 따르므로 이러한 특정 HTML 태그의 일반적 속성들을 사전에 정의한다. 물론 커스텀 컴포넌트에는 어떤 props이든 원한다면 전달할 수 있다.

### 컴포넌트로 props 전달하기

#### 스텝 1. 자식 컴포넌트로 props 전달하기

```javascript
export default function Profile() {
  return (
    <Avatar person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} size={100} />
  );
}
```

#### 스텝 2. 자식 컴포넌트에서 props 읽기

```javascript
function Avatar({ person, size }) {
  // person and size are available here
}

function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
```

### props의 기본값 정의하기

만약 props의 값이 특정되지 않는 경우 폴백하도록 할 디폴트 값을 지정하고자 한다면, props를 구조분해해 파라미터 바로 뒤에 `=` 연산자와 값을 위치시키면 된다.

```javascript
function Avatar({ person, size = 100 }) {
  // ...
}
```

디폴트 값은 해당 prop으로 전달된 값이 존재하지 않거나 undefined가 전달된 경우에만 사용되며, null 또는 0이 전달되었을 때에는 사용되지 않는다.

### JSX 스프레드 문법으로 props 포워딩하기

> React에서 "props forwarding"은 부모 컴포넌트에서 받은 props를 자식 컴포넌트로 직접 전달하는 것을 말합니다. 이는 주로 고차 컴포넌트(Higher-Order Components, HOCs)나 함수 컴포넌트에서 사용됩니다.

props를 하나하나 전달하는 것은 특히나 자신의 모든 props를 자식에게 포워딩하는 경우 지나치게 반복적인 작업일 수 있다. 이런 경우 스프레드 문법을 사용하여 prop 각각을 리스팅하지 않고 자식 컴포넌트로 props 전체를 포워딩하는 것이 합리적일 것이다.

```javascript
function MyComponent({ children, ...props }) {
  return <ChildComponent {...props}>{children}</ChildComponent>;
}
```

그러나 **스프레드 문법은 제한적으로 사용되어야 한다**. 만약 모든 컴포넌트에서 스프레드 문법을 사용하고 있다면 무언가 잘못되었음을 감지해야 한다. 이런 경우 차라리 컴포넌트를 분리하고 JSX인 children prop을 전달하는 것이 더 나은 방법일 수 있다.

### JSX를 children prop으로 전달하기

어떤 컨텐츠를 JSX 태그 안에 네스팅한다면, 부모 컴포넌트는 children이라는 prop으로 해당 컨텐츠를 전달받는다.

```javascript
import Avatar from "./Avatar.js";

function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: "Katsuko Saruhashi",
          imageId: "YfeOqp2",
        }}
      />
    </Card>
  );
}
```

### props는 어떻게 변화하는가?

time과 color를 props로 전달받는 Clock 컴포넌트가 있다고 생각해보면, 컴포넌트는 매번 다른 props를 전달받는 것으로 보일 것이다.

하지만 props 자체는 **immutable** 하다. 즉 한 컴포넌트가 props를 변경하기 위해서는 부모 컴포넌트에 다른 props, 즉 새로운 객체를 보내줄 것을 **요청**해야 한다. 그러면 이전 props 객체는 사라지고 자바스크립트 엔진은 해당 메모리를 해제할 것이다.

**props를 직접 바꾸려고 하지 말자!** 만약 유저 인풋에 응답해야 한다면 props 자체를 변경하는 것이다 아니라 **set state** 함수를 호출해야 한다.
