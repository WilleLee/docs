# UI 기술하기

## 첫 컴포넌트

리액트 어플리케이션의 각각이 고립된 UI 조각인 컴포넌트들로 이루어진다. 리액트 컴포넌트는 **마크업과 함께 뿌려지는 자바스크립트 함수**이다.

### 컴포넌트: 블록을 형성하는 UI

리액트는 HTML 마크업, CSS, 자바스크립트를 커스텀 컴포넌트들, 즉 재사용 가능한 UI 요소들로 합칠 수 있도록 돕는다. 이로써 프로젝트가 거대해질수록 다양한 디자인 요소들을 사전에 작성한 컴포넌트들로 구성하여 개발 시간을 획기적으로 단축하게 된다.

### 컴포넌트 정의하기

- 스텝 1: 컴포넌트를 export한다.
- 스텝 2: 함수를 정의한다.
- 스텝 3: 마크업을 추가한다. (JSX 문법을 이용하면 자바스크립테 마크업 언어를 삽입할 수 있다.)

### 컴포넌트 네스팅 및 조직화

컴포넌트는 일반적인 자바스크립트 함수이므로 하나의 파일에 다수의 컴포넌트를 위치시킬 수 있다. 이는 컴포넌트가 상대적으로 작거나 서로 밀접하게 관련되어 있는 경우 유용하다. 물론 파일에 너무 많은 컴포넌트가 자리하게 되면 언제든지 특정 컴포넌트를 다른 파일로 분리시킬 수 있다.

가령 Profile 컴포넌트가 Gallery 컴포넌트 안에서 렌더링된다면, Gallery 컴포넌트를 부모 컴포넌트라고 하고, 그 안에서 렌더링 되는 각각의 Profile 컴포넌트는 자식 컴포넌트가 된다. 이처럼 리액트에서는 컴포넌트를 한 번 정의한 후 여러 장소에서 원하는 만큼 재사용할 수 있다.

## 컴포넌트의 import 및 export

- 스텝 1: 컴포넌트를 정의할 새로운 자바스크립트 파일을 만든다.
- 스텝 2: 해당 파일로부터 함수 컴포넌트를 export 한다.
- 스텝 3: 이 컴포넌트를 사용할 파일에서 import 한다.

## JSX로 마크업 작성하기

수 년 간 웹 개발자들은 컨텐츠는 HTML로, 디자인은 CSS로, 로직은 자바스크립트로, 각각 분리된 파일에 작성해왔다. 어플리케이션의 컨텐츠가 HTML로 마크업되는 한편 페이지의 로직은 자바스크립트 코드로 분리되어 존재한 것이다.

하지만 웹의 상호작용성이 중요해지면서 로직이 컨텐츠를 결정해야 하는 경우가 많아졌다. 이것이 리액트에서 컴포넌트라고 하는 동일한 공간에 렌더링 로직과 마크업을 함께 작성하는 이유이다.

### JSX 규칙

1. 단 하나의 루트 요소만을 반환하라.
2. 모든 태그들을 닫아라. e.g. `<img />`
3. 대부분의 속성을 camelCase로 작성하라.

## 중괄호를 이용한 자바스크립트 표현식 삽입

JSX는 HTML과 유사한 마크업을 자바스크립트 파일 내에 작성하도록 하여 렌더링 로직과 컨텐츠를 동일한 공간에 둘 수 있도록 한다. 물론 그러한 마크업 내부에 약간의 자바스크립트 로직을 추가하거나 동적인 속성을 참조해야 하는 경우가 있을텐데, 이때는 JSX에서 중괄호를 사용하면 된다.

### 따옴표로 문자열 전달하기

문자열 속성을 JSX에 전달하고자 한다면 작은 따옴표나 큰 따옴표로 이를 감싸면 된다.

```javascript
export default function Avatar() {
  return (
    <img
      className="avatar"
      src=“blahblah.com/avatars/123.png“
      alt=“awesome picture”
    />
  );
}
```

그러나 가령 src나 alt로 전달할 문자를 동적으로 정의하고자 한다면, **따옴표를 중괄호로 대체하여 자바스크립트 값을 이용**하도록 하면 된다.

```javascript
export default function Avatar() {
  const avatar = “blahblah.com/avatars/123.png“;
  const description = “awesome picture”;
  return (
    <img
      className="avatar"
      src={avatar}
      alt={description}
    />
  );
}
```

### 중괄호 사용하기: 자바스크립트 세계로

JSX에서는 중괄호를 이용해 그 안에서 자바스크립트를 이용할 수 있다. 아래 예시에서는 `name`이라는 변수에 이름 하나를 먼저 선언하고, 이를 `<h1>` 태그 안에서 중괄호로 임베드한다.

```javascript
export default function TodoList() {
  const name = “Wille Lee”;
  return (
    <h1>{name}'s To Do List</h1>
  );
}
```

> **어떤 경우에 중괄호를 사용하는가?**  
> JSX에서는 두 가지 경우에서만 중괄호를 사용할 수 있다.
>
> 1. JSX 태그 바로 아래에 텍스트로 삽입. e.g. `<h1>{name}</h1>`은 가능하지만, `<{tag}>Wille</ {tag}>`은 불가능하다.
> 2. `=` 표시 바로 뒤에 속성으로 삽입. e.g. `src={avatar}`

### 중복 중괄호 사용하기: CSS를 포함한 객체의 전달

JSX에서는 문자열, 숫자 등 뿐만 아니라 객체 또한 전달할 수 있다. 이 경우 반드시 객체를 또 하나의 중괄호로 감싸야만 한다. e.g. `person={{ name: “Wille”, age: 29 }}`

## 컴포넌트로 props 전달하기

리액트 컴포넌트들은 서로 소통하기 위해 props를 사용한다. 모든 부모 컴포넌트는 props 전달을 통해 자식 컴포넌트로 특정 정보를 보낼 수 있다. 이때 props로는 객체, 배열, 함수를 포함한 모든 자바스크립트 값이 전달될 수 있다.

### 익숙한 props

props는 JSX 태그로 보내는 정보이다. 예를 들어 className, src, alt, width, height 등은 `<img />` 태그로 보낼 수 있는 props이다. ReactDOM은 HTML 표준을 따르므로 이러한 특정 HTML 태그의 일반적 속성들을 사전에 정의한다. 물론 커스텀 컴포넌트에는 어떤 props이든 원한다면 전달할 수 있다.

### 컴포넌트로 props 전달하기

#### 스텝 1. 자식 컴포넌트로 props 전달하기

```javascript
export default function Profile() {
  return (
    <Avatar person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} size={100} />
  );
}
```

#### 스텝 2. 자식 컴포넌트에서 props 읽기

```javascript
function Avatar({ person, size }) {
  // person and size are available here
}

function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
```

### props의 기본값 정의하기

만약 props의 값이 특정되지 않는 경우 폴백하도록 할 디폴트 값을 지정하고자 한다면, props를 구조분해해 파라미터 바로 뒤에 `=` 연산자와 값을 위치시키면 된다.

```javascript
function Avatar({ person, size = 100 }) {
  // ...
}
```

디폴트 값은 해당 prop으로 전달된 값이 존재하지 않거나 undefined가 전달된 경우에만 사용되며, null 또는 0이 전달되었을 때에는 사용되지 않는다.

### JSX 스프레드 문법으로 props 포워딩하기

> React에서 "props forwarding"은 부모 컴포넌트에서 받은 props를 자식 컴포넌트로 직접 전달하는 것을 말합니다. 이는 주로 고차 컴포넌트(Higher-Order Components, HOCs)나 함수 컴포넌트에서 사용됩니다.

props를 하나하나 전달하는 것은 특히나 자신의 모든 props를 자식에게 포워딩하는 경우 지나치게 반복적인 작업일 수 있다. 이런 경우 스프레드 문법을 사용하여 prop 각각을 리스팅하지 않고 자식 컴포넌트로 props 전체를 포워딩하는 것이 합리적일 것이다.

```javascript
function MyComponent({ children, ...props }) {
  return <ChildComponent {...props}>{children}</ChildComponent>;
}
```

그러나 **스프레드 문법은 제한적으로 사용되어야 한다**. 만약 모든 컴포넌트에서 스프레드 문법을 사용하고 있다면 무언가 잘못되었음을 감지해야 한다. 이런 경우 차라리 컴포넌트를 분리하고 JSX인 children prop을 전달하는 것이 더 나은 방법일 수 있다.

### JSX를 children prop으로 전달하기

어떤 컨텐츠를 JSX 태그 안에 네스팅한다면, 부모 컴포넌트는 children이라는 prop으로 해당 컨텐츠를 전달받는다.

```javascript
import Avatar from "./Avatar.js";

function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: "Katsuko Saruhashi",
          imageId: "YfeOqp2",
        }}
      />
    </Card>
  );
}
```

### props는 어떻게 변화하는가?

time과 color를 props로 전달받는 Clock 컴포넌트가 있다고 생각해보면, 컴포넌트는 매번 다른 props를 전달받는 것으로 보일 것이다.

하지만 props 자체는 **immutable** 하다. 즉 한 컴포넌트가 props를 변경하기 위해서는 부모 컴포넌트에 다른 props, 즉 새로운 객체를 보내줄 것을 **요청**해야 한다. 그러면 이전 props 객체는 사라지고 자바스크립트 엔진은 해당 메모리를 해제할 것이다.

**props를 직접 바꾸려고 하지 말자!** 만약 유저 인풋에 응답해야 한다면 props 자체를 변경하는 것이다 아니라 **set state** 함수를 호출해야 한다.

## 조건부 렌더링

리액트에서는 `if` 문, `&&` 연산자, 삼항 연산자 같은 자바스크립트 문법을 통해 JSX를 조건부로 렌더링할 수 있다.

## 리스트 렌더링하기

리액트에서는 자바스크립트의 `filter()`, `map()` 같은 매서드를 이용해 데이터 배열을 필터링하여 해당 정보를 반영하는 컴포넌트의 배열을 생성할 수 있다.

### 배열로부터 데이터 렌더링하기

#### 스텝 1. 데이터를 배열로 옮긴다.

#### 스텝 2. 새로운 JSX 노드 배열을 생성하도록 `map()` 매서드를 사용한다.

#### 스텝 3. 래핑 태그에 children prop으로 전달한다.

### key를 통해 배열 각 항목 구분하기

배열의 각 아이템 컴포넌트에는 해당 아이템을 특정하는 문자열 또는 숫자의 key prop이 전달되어야 한다. 가령 `map()` 매서드 바로 아래에 있는 JSX 노드는 항상 key prop을 필요로 한다.

key는 배열의 어떤 아이템이 각 컴포넌트에 상응하는지를 리액트에게 알려주는 역할을 한다. 이를 통해 리액트는 각 컴포넌트가 어떤 것을 렌더링해야 하는지 알 수 있게 된다.잘 구성된 key는 리액트가 어떤 일이 벌어졌는지 정확히 추론하도록 도와주고, DOM tree가 정상적으로 업데이트되도록 한다.

`map()` 아래에 `<></>` 프래그먼트 문법을 사용하고 싶다면(`<div>` 등 다른 태그로 요소 돔 노드를 감싸고 싶지 않다면) 리액트 라이브러리에서 Fragment 컴포넌트를 import하여 사용할 수 있다.

### key 사용 규칙

1. key는 형제들 사이에서 고유해야 한다. 서로 다른 배열의 JSX 노드가 동일한 key를 갖는 것은 상관 없다.
2. key는 변경되어서는 안 된다. 만약 key가 렌더링 과정에서 생성/변경된다면 key는 그 목적을 이루지 못할 것이다.

## 컴포넌트를 순수하게 유지하기

자바스크립트 함수는 순수할 수 있다. 순수한 함수는 단순 계산만을 수행한다. 보다 엄격하게 컴포넌트를 순수한 함수로 작성한다면, 당황스런 버그나 예상 못한 동작을 피할 수 있다. 이를 위해서는 몇 가지 규칙을 지켜야 한다.

### 순수성: 공식으로서의 컴포넌트

컴퓨터 과학에서 순수한 함수는 아래 특징을 갖는다.

1. 순수한 함수는 자신의 고유한 동작만을 신경 쓴다. 즉 함수가 호출되기 전에 존재하던 객체나 변수를 변경하지 않는다.
2. 동일 인풋에 대해 항상 동일 아웃풋을 반환한다. 즉 함수가 호출될 때마다 동일한 인풋이 전달되면 항상 동일한 결과를 반환한다. e.g. f(x) = 2x

### 사이드 이팩트: (비)의도적 결과

리액트의 렌더링 프로세스는 항상 순수해야 한다. 컴포넌트는 고유한 JSX만을 반환해야 하며, 렌더링 이전부터 존재하는 객체나 변수를 변경해서는 안 된다.

> **Strict Mode로 순수하지 않은 계산 찾아내기**  
> 리액트에는 렌더링 중에 읽을 수 있는 세 종류의 인풋, props, state, context가 있는데, 이들은 항상 read-only로 다루어져야 한다.  
> 만약 유저 인풋에 반응하여 무언가를 **변경**하고자 한다면, 변수 자체에 새로운 값을 전달하는 것이 아니라, **set state** 매서드를 이용해야 한다. 절대로 이전부터 존재하는 변수나 객체를 컴포넌트 렌더링 중에 변경해서는 안 된다.  
> 리액트는 개발자 모드에서 각 컴포넌트 함수를 두 번 호출하는 **Strict Mode**를 제공한다. 컴포넌트 함수를 두 번 호출함으로써 strict mode는 이러한 순수성의 규칙을 깨는 컴포넌트를 찾는 데 도움을 준다.  
> 한편 strict mode는 production 환경에서는 비활성화되므로, 유저의 앱 이용을 지연시키지 않는다. Strict mode를 이용하려면 루트 컴포넌트를 `<React.StrictMode>` 태그로 감싸면 된다.

### 지역적 뮤테이션: 컴포넌트의 작은 비밀

컴포넌트가 렌더링 이전부터 존재하는 변수를 변경하는 것을 뮤테이션이라고 부른다. 순수한 함수는 함수 스코프 바깥의 변수 또는 함수 호출 이전에 생성된 객체에 뮤테이션을 일으키지 않는다.

하지만 **렌더링 도중에 생성한 변수나 객체를 변경하는 것은 허용된다.** 이를 지역적 뮤테이션이라고 부른다.

### 사이드 이팩트를 일으킬 _수 있는_ 곳

함수형 프로그래밍이 순수성에 크게 의존하는 한편, **어떤 것**은 프로그래밍적 의도에서 변경되어야 할 때가 있다.

화면을 업데이트하고 애니메이션을 실행하고 데이터를 바꾸는 등의 변경들은 모두 **사이드 이팩트**라 불린다. 이러한 사이드 이팩트는 렌더링 도중에가 아니라 렌더링에 부차적으로, **사이드에서(on the side)**에서 일어난다.

리액트에서 사이드 이팩트는 보통 이벤트 핸들러 내에 속한다. 여기서 이벤트 핸들러는 유저가 특정 액션을 수행할 때 리액트가 실행하는 함수들이다. 이때 이벤트 핸들러는 컴포넌트 안에서 정의된다 할지라도 렌더링 중에 실행되지는 않는다. 따라서 이벤트 핸들러는 순수하지 않아도 된다.

만약 다른 모든 수를 사용해버렸음에도 원하는 사이드 이팩트를 일으킬 적합한 이벤트 핸들러를 찾지 못했다면 컴포넌트에서 `useEffect` 호출을 통해 반환된 JSX에 이벤트 핸들러를 결합시킬 수도 있다. 이는 리액트에게 이벤트 핸들러를 렌더링 이후에, 사이드 이팩트가 허용될 때 실행하도록 한다. **하지만 이는 권장되지 않는다**.

> **리액트에서 순수성이 중요한 이유**
>
> - 컴포넌트가 다양한 환경에서 실행될 수 있게 해준다.
> - 인풋이 변화하지 않은 컴포넌트의 리렌더링을 스킵(메모이제이션)하여 전체 퍼포먼스를 향상시킨다. 순수함수들은 항상 동일한 결과를 반환하기 때문에 안전하게 캐시될 수 있다.
> - 깊은 컴포넌트 트리를 렌더링하는 중에 어떤 데이터가 변화한다면 리액트는 만료된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링 프로세스를 재시작한다. 순수성은 언제든 안전하게 계산을 중지하도록 해준다.

## 트리 구조로서의 UI 이해하기

리액트 앱의 모델은 많은 컴포넌트들의 상호 네스팅으로 그려진다. 그렇다면 리액트는 어떻게 앱의 컴포넌트 구조를 따라가는가?

리액트를 포함한 많은 UI 라이브러리들은 트리 형태로 UI를 만든다. 앱을 하나의 트리로 생각하는 것은 컴포넌트 간의 관계를 이해하는 데 유용하며, 이는 퍼포먼스 및 state 관리에도 도움이 된다.

### 트리로서의 UI

트리는 아이템들 간의 관계 모델이고, 대부분의 경우 이런 트리 구조를 통해 UI가 표현된다. 예를 들어 브라우저는 트리 구조를 통해 HTML(DOM 트리), CSS(CSSOM) 모델을 그린다

리액트 또한 리액트 앱 안의 컴포넌트들 간 관계를 관리하고 형성하기 위해 트리 구조를 이용한다. 이러한 트리 구조는 리액트 앱에서 어떻게 데이터가 흐르는지, 그리고 렌더링과 앱 크기를 어떻게 최적화하는지 이해하는 데 있어서도 중요하다.

### 렌더 트리

컴포넌트가 갖는 주요 특징 가운데 하나는 다른 컴포넌트들을 통해 새로운 컴포넌트를 구성할 수 있다는 것이다. 컴포넌트를 네스팅할 때 부모 컴포넌트, 자식 컴포넌트 개념을 이야기하게 되는데, 이때 각 부모 컴포넌트는 자신이 다른 컴포넌트의 자식 컴포넌트일 수 있다. 리액트 앱을 렌더링할 때 우리는 이러한 관계를 **렌더 트리**라고 알려진 하나의 트리에 담아낸다.

![render tree](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Frender_tree.dark.png&w=1080&q=75)

> **렌더 트리 내에서 HTML 태그는 어디에?**
>
> - 렌더 트리는 리액트 컴포넌트로만 이루어진다.
> - UI 프레임워크 중 하나인 리액트는 플랫폼에 구애받지 않는다(platform agnostic).
> - react.dev에서는 HTML 마크업을 UI 프리미티브로 사용하는 웹에 렌더링할 예시들을 보여주고 있으나, 리액트 앱은 UIView나 FrameworkElement 같이 다른 UI 프리미티브를 이용하는 여러 모바일/데스트탑 플랫폼에도 렌더링 될 수 있다.
> - 위의 UI 프리미티브들은 리액트에 속하는 것이 아니다. 리액트 렌더 트리는 앱이 어떤 플랫폼에 렌더링되는가에 상관 없이 리액트 앱에 인사이트를 제공할 수 있다.

### 모듈 의존성 트리

트리 형태로 그려질 수 있는 리액트 앱 내의 또 다른 관계성은 앱의 모듈 의존성이다.

컴포넌트와 로직을 서로 다른 파일로 쪼갤 때 컴포넌트나 함수, 상수를 export하는 JS 모듈이 생성된다. 모듈 의존성 트리에서 각 노드는 이런 하나하나의 모듈이고, 각 브랜치는 각 모듈의 `import` 문이다.

![module dependency tree](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fmodule_dependency_tree.dark.png&w=1080&q=75)

모듈 의존성 트리의 루트 노드는 엔트리포인트가 되는 파일인 루트 모듈이며, 일반적으로 루트 노드는 루트 컴포넌트를 갖는다.

동일한 앱의 렌더 트리와 비교하면 유사한 구조가 있기는 하지만 몇 가지 주의할 만한 차이도 있다.

1. 트리를 형성하는 노드들은 컴포넌트가 아닌 모듈을 나타낸다.
2. 컴포넌트가 아닌 모듈도 트리에 표현된다. 이와 달리 렌더 트리는 컴포넌트만으로 이루어진다.

의존성 트리는 어떤 모듈이 리액트 앱을 실행하는 데 필수적인지 확인하는 데 유용하다. 리액트 앱을 production 모드로 배포할 때 보통은 빌드 과정이 있어서 모든 필요한 자바스크립트를 번들링한다. 이를 번들러가 수행하는데, 번들러가 의존성 트리를 사용하여 어떤 모듈들이 포함되어야 하는지 결정하는 것이다.

번들 사이즈가 커지면 앱 실행에 지연이 발생한다. 의존성 트리에 대한 감각을 갖는 것은 이러한 이슈들을 디버깅하는 데 도움이 된다.
