# 상태 관리하기

어플리케이션이 커질수록 상태를 어떻게 조직화할 것이고 컴포넌트 간의 데이터 흐름은 어떻게 할 것인지에 대해 깊이 생각해봐야 한다. 사용하지 않거나 중복된 상태는 버그의 주된 원인이다. 여기서는 상태를 어떻게 잘 구조화하고, 상태 업데이트 로직을 어떻게 유지 가능하게 하며, 멀리 떨어진 컴포넌트들이 어떻게 상태를 공유하게 할 것인지 살펴볼 것이다.

## 상태를 통해 인풋에 반응하기

리액트는 서술형(declarative)의 방식으로 UI를 조작하게 한다. UI의 개별 요소를 직접적으로 다루는 대신, 컴포넌트가 가질 수 있는 서로 다른 상태들을 묘사하고, 유저 인풋에 반응하여 그러한 상태들 사이를 컴포넌트가 오가게 하는 것이다. 이는 디자이너들이 UI를 생각하는 방식과 유사하다.

### 서술형 UI는 명령형 UI와 어떻게 다른가?

UI의 상호작용을 설계한다고 생각해보면, 아마 유저의 액션에 반응하여 UI가 어떻게 변해야 하는가에 대해 고민하게 될 것이다. 유저가 대답을 제출하도록 하는 `form`에 대해 생각해보자.

1. 인풋에 무언가 입력하면 제출 버튼이 활성화된다.
2. 제출 버튼을 누르면 인풋과 버튼이 비활성화되고 `<Spinner>`가 나타난다.
3. 네트워크 요청이 성공하면 `form`이 가려지고 `"thank you"`라는 메세지가 나타난다.
4. 네트워크 요청이 실패하면 에러 메세지가 나타나고 인풋이 다시 활성화된다.

명령형 프로그래밍(imperative programming)에서는 위의 논리적 플로우가 개발자의 코드의 시행방식과 정확히 일치한다. 발생하는 이벤트에 따라 UI를 조작하는 명확한 지시사항들을 작성해야 하는 것이다. 이런 방식의 UI 프로그래밍에서 `form`은 리액트를 필요로 하지 않으며, 브라우저 DOM만을 이용한다. 이것이 **명령형**이라 불리는 것은 개발자가 각 엘리먼트에게 명령을 전달해야 하기 때문이다.

UI를 명령적으로 조작하는 것은 분리된 예시에서 충분히 잘 작동하지만, 복잡한 시스템에서는 기하급수적으로 관리하기 힘들어진다. **리액트는 이런 문제를 해결하기 위해 만들어졌다.** 리액트에서는 UI를 직접적으로 조작하지 않아도 된다. 대신 **무엇을 보여주고 싶은지 선언**하면 되며, 그러면 리액트는 UI를 어떻게 업데이트할지 계산해낸다.

### 서술적 방식으로 UI에 대해 생각하기

리액트로 생각하는 방법에 대해 이해하기 위해 위의 UI를 리액트로 다시 시행해보자.

1. 컴포넌트의 서로 다른 시각적 상태들을 **확인한다**(identify).
2. 그러한 상태 변화를 촉발하는 것이 무언인지 **결정한다**(determine).
3. `useState`를 이용해 그 상태를 메모리에 **표현한다**(represent).
4. 본질적이지 않은 상태 변수들은 **제거한다**(remove).
5. 이벤트 핸들러들을 **연결하여**(connect) 상태의 업데이트를 구현한다.

#### 스텝 1. 컴포넌트의 서로 다른 시각적 상태들을 확인한다

컴퓨터 과학에서는 몇 가지 상태 가운데 하나가 되는 것을 **상태 머신**(state machine)이라고 한다. 또 디자이너들과 협업하다보면 서로 다른 **시각정 상태**를 표현하는 목업(mockup)을 만들어야 할 때가 있다. 리액트는 디자인과 컴퓨터 과학의 교차 지점에 선다.

우선 유저가 보게 될 UI의 서로 다른 **상태들**을 모두 시각화해야 한다:

- 비어있음 : `<Form>`은 `disabled`인 `<Submit>` 버튼을 갖는다.
- 타이핑 중 : `<Form>`은 `disabled`가 아닌 `<Submit>` 버튼을 갖는다.
- 제출 중 : `<Form>`이 완전히 `disabled`되고 `<Spinner>`가 나타난다.
- 성공 : `<Form>`이 사라지고 `"thank you"`라는 메세지가 나타난다.
- 실패 : 타이핑 중 상태와 동일하지만 부가적인 에러 메세지가 나타난다.

디자이너가 사고하는 바와 같이 리액트 개발자도 로직을 추가하기 전에 서로 다른 상태에 대한 **목업**을 생성하고자 할 것이다. `form`의 시각적 부분만을 보여주는 목업 예시를 살펴보면 이는 `"empty"`를 디폴트 값으로 갖는 `status`라는 prop에 의해 제어된다:

```jsx
export default function Form({ status = "empty" }) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}
```

#### 스텝 2. 그러한 상태 변화를 촉발하는 것이 무언인지 결정한다

상태 업데이트는 두 가지 종류의 인풋에 반응하여 촉발될 수 있다.

- **사람 인풋(human input)** e.g. 버튼 클릭, 타이핑, 링크로 네비게이션 등
- **컴퓨터 인풋(computer input)** e.g. 네트워크 리스펀스의 전달, 타임아웃, 이미지 로딩 등

두 경우 모두에서 **UI를 업데이트하기 위해서는 상태 변수를 설정해야 한다.** 위 `<Form>` 예시를 살펴보자면 아래 몇 가지 인풋에 반응하여 상태를 변화시켜야 할 것이다.

- **텍스트 인풋의 변화**(사람 인풋)는, 텍스트 박스가 비어있는지 아닌지 여부에 따라 `"empty"` 상태를 `"typing"` 상태로 전환시키거나 원래대로 되돌려야 한다.
- `<Submit>` **버튼의 클릭**(사람 인풋)은 `"submitting"` 상태로 전환시켜야 한다.
- **성공적인 네트워크 리스펀스**(컴퓨터 인풋)는 `"success"` 상태로 전환시켜야 한다.
- **실패한 네트워크 리스펀스**(컴퓨터 인풋)는 적절한 에러 메세지와 함께 `"error"` 상태로 전환시켜야 한다.

이러한 플로우를 시각화하기 위해 각 상태를 레이블링된 원으로, 그리고 두 가지 상태 사이에서의 변화를 화살표로 그려보면 로직을 실제 실행하기 전에 버그를 잡아낼 수 있을 것이다.

![visualizing a flow of state updates](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.dark.png&w=1920&q=75)

#### 스텝 3. `useState`를 이용해 그 상태를 메모리에 표현한다

다음으로는 `useState`를 이용해 메모리에 컴포넌트의 시각적 상태를 표현해야 한다. 여기서는 단순성을 추구해야 하는데, 상태의 각 조각이 "움직이는 조각"이라면 가능한 한 적은 수의 "움직이는 조각들"을 표현해야 할 것이다.

우선 **반드시 존재해야만 하는** 상태로 시작해야 한다(e.g. `answer`, `error`). 그러고 나서는 나타내고자 하는 시각적 상태들 중 하나를 표현하는 상태 변수가 필요할 것이다. 이를 메모리에 표현하는 데에는 하나 이상의 방법이 있겠으나, 최고의 방법이 떠오르지 않는다면 우선은 모든 가능한 시각적 상태를 다룬다고 **확인이 들 정도의** 충분한 수의 상태를 추가하는 데에서 시작하고 추후 리팩터링해가면 된다.

```jsx
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

#### 스텝 4. 본질적이지 않은 상태 변수들은 제거한다

상태 구조를 리팩터링하는 데 시간을 들이는 일은 컴포넌트를 읽기 쉽게 하고, 상태의 중복을 줄이며, 의도되지 않은 요소들을 피하게 한다. 여기서 중점적인 지향점은 **유저가 보기를 원하는 어떤 UI도 표현하지 않는 상태가 메모리에 존재하는 경우를 방지하는 것**이다.

이때 아래와 같은 질문들을 던져볼 수 있을 것이다:

- **이 상태가 역설을 낳을 수도 있는가?**  
  가령 `isTyping`과 `isSubmitting`은 동시에 `true`일 수 없다. 역설은 일반적으로 상태가 충분히 제한되지 않은 경우를 의미한다. 두 개의 불리언 값은 네 가지 가능한 조합을 만들겠지만, 이때 유의미한 상태는 오직 세 가지이다. "불가능한" 상태를 제거하기 위해 이들을 `status`라는 상태로 묶어 `"typing"`, `"submitting"`, `"success"` 중 하나만을 표현하도록 할 수 있다.
- **동일한 정보가 다른 상태 변수에 의해 이미 표현될 수 있는가?**  
  또 다른 역설은 `isEmpty`와 `isTyping`이 동시에 `true`일 수 없다는 것이다. 이들을 분리된 상태 변수로 만듦으로써 이들이 동기화되지 않고 버그 발생의 리스크를 안게 되는 것이다. 다행히 `isEmpty`를 제거하고 `answer.length === 0` 표현문을 이용해 `isTyping`을 대신할 수 있다.
- **다른 상태의 반대값을 통해 동일한 정보를 얻을 수 있는가?**  
  `error !== null`을 체크할 수 있기 때문에 `isError`는 불필요하다.

이런 과정을 거치면 본질적인 상태 변수 세 가지가 남게 된다.

```jsx
const [answer, setAnswer] = useState("");
const [error, setError] = useState(null);
const [status, setStatus] = useState("typing"); // "typing", "submitting", or "success"
```

> > **리듀서를 이용해 "불필요한" 상태 제거하기**  
> > 위 세 가지 변수는 `form`의 상태를 표현하는 데 충분하긴 하지만, 여전히 사이사이의 표현되지 않는 상태들이 존재하기는 한다. 가령 `null`이 아닌 `error`는 `status`가 `"success"`인 경우 성립하지 않는다. 상태를 보다 정확하게 형상화하기 위해서는 이를 리듀서에 넣어볼 수 있을 것이다. 리듀서는 다양한 상태 변수를 하나의 객체로 합치고 모든 연관된 로직들을 통합하도록 한다.

#### 스텝 5. 이벤트 핸들러들을 연결하여 상태의 업데이트를 구현한다

끝으로 상태를 업데이트하는 이벤트 핸들러를 생성하면 된다.

```jsx
import { useState } from "react";

export default function Form() {
  const [answer, setAnswer] = useState("");
  const [error, setError] = useState(null);
  const [status, setStatus] = useState("typing");

  if (status === "success") {
    return <h1>That's right!</h1>;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus("submitting");
    try {
      await submitForm(answer);
      setStatus("success");
    } catch (err) {
      setStatus("typing");
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === "submitting"}
        />
        <br />
        <button disabled={answer.length === 0 || status === "submitting"}>
          Submit
        </button>
        {error !== null && <p className="Error">{error.message}</p>}
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== "lima";
      if (shouldError) {
        reject(new Error("Good guess but a wrong answer. Try again!"));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```

## 상태 구조 선택하기

### 상태 구조의 원리

상태를 갖는 컴포넌트를 작성할 때에는 얼마나 많은 상태 변수를 사용할 것이고 각 상태의 데이터들은 어떤 형태를 가져야 하는가에 대해 선택해야 한다. 아래는 최적화를 위해 더 나은 선택을 하기 위한 몇 가지 원칙들이다.

1. **상관성 있는 상태들을 그룹으로 묶기**  
   매번 한 번에 둘 이상의 상태 변수가 동시에 업데이트되어야 한다면, 그들을 하나의 상태 변수로 합치는 것을 고려해볼 수 있다.
2. **상태 내의 모순 피하기**  
   만약 상태의 조각들이 상호 부정관계에 있다면 실수의 여지가 생길 수 있다.
3. **불필요한 상태 피하기**  
   props나 이미 존재하는 상태 변수로부터 어떤 정보를 계산해낼 수 있다면, 해당 정보를 컴포넌트의 상태로 추가하는 것은 피해야 한다.
4. **상태의 중복 피하기**  
   다수의 상태 변수에 걸쳐서 동일한 데이터가 중복된다면 그들을 동기화시키기 어려워질 것이다. 따라서 가능한 한 상태의 중복을 제거해야 한다.
5. **깊게 네스팅된 상태는 피하기**  
   고도로 계층화된 상태는 업데이트하기 매우 어렵다. 가능하다면 상태를 단층 구조로 만드는 것이 좋다.

이러한 원칙들 이면의 목적은 **상태를 쉽게 업데이트할 수 있도록 만드는 것**이다. 상태에서 불필요하고 중복된 데이터를 제거하는 것은 상태의 모든 조각들이 조화를 이루도록 한다.이는 데이터베이스 엔지니어가 데이베이스 구조를 "노멀라이즈"하여 버그의 가능성을 줄이는 것과 유사하다.

이제 이 원칙들이 어떻게 적용될 수 있는지 자세히 살펴보자.

### 서로 관련된 상태들을 그룹으로 묶기

하나의 상태 변수를 사용하는 것이 좋을지 여러 상태 변수를 사용하는 것이 좋을지 확신이 서지 않을 때가 있을 수 있다.

```jsx
const [x, setX] = useState(0);
const [y, setY] = useState(0);

const [position, setPosition] = useState({ x: 0, y: 0 });
```

위 두 방식 모두 기술적으로는 사용 가능하다. 하지만 **만약 어떤 두 개의 상태 변수가 항상 함께 변화한다면, 그들을 하나의 상태 변수로 합치는 것이 좋은 생각일 수 있다.** 그렇게 하면 그들이 항상 동기화되도록 하는 것을 잊지 않게 될 것이다.

한편 상태의 조각이 얼마나 많이 필요하게 될지 확실하지 않을 때에도 객체 또는 배열 형태의 데이터를 사용할 수 있다.

### 상태 내의 모순 피하기

`isSending`, `isSent` 상태 변수를 이용해 호텔 피드백을 작성하게 하는 폼이 있다고 생각해보자.

```jsx
import { useState } from "react";

export default function FeedbackForm() {
  const [text, setText] = useState("");
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button disabled={isSending} type="submit">
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise((resolve) => {
    setTimeout(resolve, 2000);
  });
}
```

위 코드는 작동하기는 하지만 "불가능한" 상태의 여지를 남긴다. 가령 `setIsSent`와 `setIsSending`을 함께 호출하는 것을 까먹는다면 `isSending`과 `isSent`가 동시에 `true`인 상황에 봉착하게 될 것이다. 컴포넌트가 복잡해질수록 어떤 일이 일어났는지 이해하기는 더 어려워진다.

`isSending`과 `isSent`는 동시에 `true`일 수 없으므로 이들을 `status`라는 하나의 상태 변수로 대체하여 `typing`, `sending`, `sent`의 세 가지 가능한 상태 중 하나를 취하도록 하는 것이 더 나을 것이다.

```jsx
import { useState } from "react";

export default function FeedbackForm() {
  const [text, setText] = useState("");
  const [status, setStatus] = useState("typing");

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus("sending");
    await sendMessage(text);
    setStatus("sent");
  }

  const isSending = status === "sending";
  const isSent = status === "sent";

  if (isSent) {
    return <h1>Thanks for feedback!</h1>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      <br />
      <button disabled={isSending} type="submit">
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise((resolve) => {
    setTimeout(resolve, 2000);
  });
}
```

### 불필요한 상태 피하기

컴포넌트의 props나 이미 존재하는 상태 변수를 통해 렌더링 중에 어떤 정보를 계산할 수 있다면 해당 정보를 컴포넌트의 상태에 놓아서는 **안 된다**.

```jsx
const [firstName, setFirstName] = useState("");
const [lastName, setLastName] = useState("");
const [fullName, setFullName] = useState("");
```

위에는 `firstName`, `lastName`, `fullName` 세 가지 상태 변수가 선언되었는데, 이때 **렌더링 중에 언제나 다른 두 상태를 통해 `fullName`의 값을 연산할 수 있으므로 이는 상태에서 제거되어야 한다.**

```jsx
const [firstName, setFirstName] = useState("");
const [lastName, setLastName] = useState("");

const fullName = firstName + " " + lastName;
```

여기서 `fullName`은 상태 변수가 아니며 렌더링 중에 계산된다.

> > **상태로 props를 미러링하지 마라**  
> > 아래는 불필요한 상태의 일반적인 예시이다.
> >
> > ```jsx
> > function Message({ messageColor }) {
> >   const [color, setColor] = useState(messageColor);
> >   // …
> > }
> > ```
> >
> > 여기서 `color` 상태 변수는 `messageColor` prop으로 초기화된다. 문제는 **부모 컴포넌트가 이후에 `messageColor`로 다른 값을 보내더라도 `color` 상태 변수는 업데이트되지 않는다는 것**이다. 상태는 오직 첫 번째 렌더링 중에만 초기화된다.  
> > 그러므로 prop을 상태 변수로 "미러링"하는 것은 혼란을 야기할 수 있다. 대신에 `messageColor` prop을 코드 상에서 직접 사용하는 것이 낫다. 그렇게 하는 것이 부모 컴포넌트에서 전달된 prop과의 동기화를 깨뜨리지 않는 방법이다.  
> > props를 상태로 "미러링"하는 일은 특정 prop의 업데이트를 모두 무시하고 **싶을 때**에만 유의미하다. 이 경우 변수명을 prop 이름 앞에 "initial" 또는 "default"를 붙이는 형태로 지어 props의 새로운 값들이 무시될 것임을 명시하는 것이 컨벤션으로 자리잡았다.
> >
> > ```jsx
> > function Message({ initialColor }) {
> >   // The `color` state variable holds the *first* value of `initialColor`.
> >   // Further changes to the `initialColor` prop are ignored.
> >   const [color, setColor] = useState(initialColor);
> >   // …
> > }
> > ```

### 상태의 중복 피하기

```jsx
import { useState } from "react";

const initialItems = [
  { title: "pretzels", id: 0 },
  { title: "crispy seaweed", id: 1 },
  { title: "granola bar", id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.title}{" "}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

위 `<Menu>` 컴포넌트는 몇 가지 과자 중 하나를 선택하도록 한다. 여기서 선택된 아이템이 `selectedItem`이라는 상태 변수에 객체로 저장되는데, 문제는 **`selectedItem`의 내용물이 `items` 리스트 내부의 아이템들 중 하나와 동일한 객체라는 점**이다. 이는 아이템 자체에 대한 정보가 두 공간에서 중복되고 있다는 것을 의미한다. 이것이 왜 문제가 되는지는 각 아이템을 수정 가능하게 만들어보면 알 수 있다.

```jsx
import { useState } from "react";

const initialItems = [
  { title: "pretzels", id: 0 },
  { title: "crispy seaweed", id: 1 },
  { title: "granola bar", id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  function handleItemChange(id, e) {
    setItems(
      items.map((item) => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={(e) => {
                handleItemChange(item.id, e);
              }}
            />{" "}
            <button
              onClick={() => {
                setSelectedItem(item);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

여기서 선택 버튼을 먼저 클릭하고 선택된 과자의 이름을 수정하면 **인풋의 값은 업데이트되지만, 화면 아래의 메세지는 수정사항을 반영하지 않는다.** 이는 상태가 중복되어 `selectedItem`도 업데이트해야 한다는 사실을 잊었기 때문에 발생한다.

그러나 `selectedItem`을 함께 업데이트하는 방법이 있다 하더라도, 중복을 제거하는 것이 더 쉬운 해결방법인 될 것이다. 위 예시에서는 `selectedItem` 객체 대신에 상태에는 `selectedId`를 저장하고, 해당 ID 값을 가지고 `items` 배열에서 `selectedItem`을 탐색하도록 하면 된다.

```jsx
import { useState } from "react";

const initialItems = [
  { title: "pretzels", id: 0 },
  { title: "crispy seaweed", id: 1 },
  { title: "granola bar", id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find((item) => item.id === selectedId);

  function handleItemChange(id, e) {
    setItems(
      items.map((item) => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={(e) => {
                handleItemChange(item.id, e);
              }}
            />{" "}
            <button
              onClick={() => {
                setSelectedId(item.id);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

이제 **선택된** 아이템의 이름을 수정하면 아래의 메세지가 즉시 업데이트 되는데, 이는 `setItems` 세터 함수가 리렌더링을 촉발하고 `items.find(...)` 문이 업데이트된 이름을 가진 아이템을 찾아내기 때문이다.

### 깊게 네스팅된 상태는 지양하기

**상태가 쉽게 업데이트하기 힘들 정도로 지나치게 네스팅되어 있다면 이를 "플랫하게" 만드는 것을 생각해봐야 한다.**

```jsx
// places.js
export const initialTravelPlan = {
  0: {
    id: 0,
    title: "(Root)",
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: "Earth",
    childIds: [2, 10, 19, 26, 34],
  },
  2: {
    id: 2,
    title: "Africa",
    childIds: [3, 4, 5, 6, 7, 8, 9],
  },
  3: {
    id: 3,
    title: "Botswana",
    childIds: [],
  },
  4: {
    id: 4,
    title: "Egypt",
    childIds: [],
  },
  5: {
    id: 5,
    title: "Kenya",
    childIds: [],
  },
  6: {
    id: 6,
    title: "Madagascar",
    childIds: [],
  },
  7: {
    id: 7,
    title: "Morocco",
    childIds: [],
  },
  8: {
    id: 8,
    title: "Nigeria",
    childIds: [],
  },
  9: {
    id: 9,
    title: "South Africa",
    childIds: [],
  },
  10: {
    id: 10,
    title: "Americas",
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],
  },
  11: {
    id: 11,
    title: "Argentina",
    childIds: [],
  },
  12: {
    id: 12,
    title: "Brazil",
    childIds: [],
  },
  13: {
    id: 13,
    title: "Barbados",
    childIds: [],
  },
  14: {
    id: 14,
    title: "Canada",
    childIds: [],
  },
  15: {
    id: 15,
    title: "Jamaica",
    childIds: [],
  },
  16: {
    id: 16,
    title: "Mexico",
    childIds: [],
  },
  17: {
    id: 17,
    title: "Trinidad and Tobago",
    childIds: [],
  },
  18: {
    id: 18,
    title: "Venezuela",
    childIds: [],
  },
  19: {
    id: 19,
    title: "Asia",
    childIds: [20, 21, 22, 23, 24, 25],
  },
  20: {
    id: 20,
    title: "China",
    childIds: [],
  },
  21: {
    id: 21,
    title: "India",
    childIds: [],
  },
  22: {
    id: 22,
    title: "Singapore",
    childIds: [],
  },
  23: {
    id: 23,
    title: "South Korea",
    childIds: [],
  },
  24: {
    id: 24,
    title: "Thailand",
    childIds: [],
  },
  25: {
    id: 25,
    title: "Vietnam",
    childIds: [],
  },
  26: {
    id: 26,
    title: "Europe",
    childIds: [27, 28, 29, 30, 31, 32, 33],
  },
  27: {
    id: 27,
    title: "Croatia",
    childIds: [],
  },
  28: {
    id: 28,
    title: "France",
    childIds: [],
  },
  29: {
    id: 29,
    title: "Germany",
    childIds: [],
  },
  30: {
    id: 30,
    title: "Italy",
    childIds: [],
  },
  31: {
    id: 31,
    title: "Portugal",
    childIds: [],
  },
  32: {
    id: 32,
    title: "Spain",
    childIds: [],
  },
  33: {
    id: 33,
    title: "Turkey",
    childIds: [],
  },
  34: {
    id: 34,
    title: "Oceania",
    childIds: [35, 36, 37, 38, 39, 40, 41],
  },
  35: {
    id: 35,
    title: "Australia",
    childIds: [],
  },
  36: {
    id: 36,
    title: "Bora Bora (French Polynesia)",
    childIds: [],
  },
  37: {
    id: 37,
    title: "Easter Island (Chile)",
    childIds: [],
  },
  38: {
    id: 38,
    title: "Fiji",
    childIds: [],
  },
  39: {
    id: 40,
    title: "Hawaii (the USA)",
    childIds: [],
  },
  40: {
    id: 40,
    title: "New Zealand",
    childIds: [],
  },
  41: {
    id: 41,
    title: "Vanuatu",
    childIds: [],
  },
  42: {
    id: 42,
    title: "Moon",
    childIds: [43, 44, 45],
  },
  43: {
    id: 43,
    title: "Rheita",
    childIds: [],
  },
  44: {
    id: 44,
    title: "Piccolomini",
    childIds: [],
  },
  45: {
    id: 45,
    title: "Tycho",
    childIds: [],
  },
  46: {
    id: 46,
    title: "Mars",
    childIds: [47, 48],
  },
  47: {
    id: 47,
    title: "Corn Town",
    childIds: [],
  },
  48: {
    id: 48,
    title: "Green Hill",
    childIds: [],
  },
};
```

## 컴포넌트 간에 상태 공유하기

두 개의 컴포넌트에서 항상 함께 변화하는 상태를 선언하고 싶을 수 있다. 이를 위해서는 각 컴포넌트에서는 상태를 제거하고, 해당 상태를 가장 가까운 공통 부모 컴포넌트로 옮긴 다음, props로 각각으로 내려보내면 된다. 이러한 과정을 **상태를 끌어올린다**(lifting state up)고 하는데, 이는 리액트 코드를 작성하는 데 있어서 가장 일반적인 작업 중 하나이다.

### 상태를 끌어올리는 예시

```jsx
import { useState } from "react";

function Panel({ title, children }) {
  const [isActive, setIsActive] = useState(false);
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>Show</button>
      )}
    </section>
  );
}

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About">
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology">
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang="la">Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}
```

위 예시에서 부모 컴포넌트인 `<Accordion>`은 두 개의 분리된 `<Panel>` 컴포넌트를 렌더링한다. 그리고 각 `<Panel>` 컴포넌트는 불리언 값의 `isActive` 상태를 통해 해당 컨텐츠를 노출시킬지 결정한다. 이때 각 `<Panel>` 컴포넌트의 `isActive` 상태는 독립적이기 때문에 한 `<Panel>`의 버튼을 클릭하는 일은 다른 `<Panel>`의 상태에는 영향을 미치지 않는다.

**그러나 가령 이를 변경하여 매 순간 하나의 `<Panel>`의 컨텐츠만이 확장되도록 하고 싶다고 해보자.** 이 디자인대로라면 두 번째 `<Panel>`을 확장하는 순간 다른 쪽 컨텐츠는 사라져야 한다.

이런 형태로 두 `<Panel>`을 조직화하기 위해서는 세 단계에 걸쳐 부모 컴포넌트로 "상태를 끌어올려야" 한다.

1. 자식 컴포넌트에서 상태를 **제거한다**.
2. 공통 부모로부터 하드코딩된 데이터를 **전달한다**.
3. 공통 부모에 상태를 **추가하여** 이벤트 핸들러와 함께 전달한다.

### 스텝 1. 부모 컴포넌트에서 상태를 제거한다

이제 `<Panel>`의 `isActive`에 대한 제어권을 부모 컴포넌트에 줄 것이다. 이는 부모 컴포넌트가 `isActive`를 prop으로 `<Panel>`에 전달할 것임을 의미한다. `<Panel>` 컴포넌트에서 **아래 코드를 제거**하는 것에서 시작하자.

```jsx
const [isActive, setIsActive] = useState(false);
```

그런 후 이를 대신하여 `<Panel>`의 props 리스트에 `isActive`를 추가한다.

```jsx
function Panel({ title, children, isActive }) {
  // …
}
```

이러면 `<Panel>`의 부모 컴포넌트가 `isActive`를 prop으로 전달하게 됨으로써 해당 상태에 대한 제어권을 갖게 된다. 역으로 `<Panel>` 컴포넌트는 `isActive`에 대한 제어권을 상실한다.

### 스텝 2. 공통 부모로부터 하드코딩된 데이터를 전달한다

상태를 끌어올리기 위해서는 조직화하고자 하는 자식 컴포넌트들 **모두**의 가까운 공통 컴포넌트를 생성해야 한다. 예시에는 `<Accordion>` 컴포넌트가 여기 해당되는데, `<Panel>` 모두의 위에 위치하면서 그들의 props에 대한 제어권을 가지므로 어떤 `<Panel>`이 현재 활성화되어 있는지를 판단할 "source of truth"가 된다. `<Accordion>`이 `<Panel>` 모두에 `true`로 하드코딩된 `isActive`를 전달하도록 해보자. 그리고 하드코딩된 값을 변경하여 화면 상의 결과가 예상대로 나오는지 확인해보자.

```jsx
import { useState } from "react";

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About" isActive={true}>
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology" isActive={true}>
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang="la">Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}
```

### 스텝 3. 공통 부모에 상태를 추가한다

상태를 끌어올리는 일은 많은 경우 상태에 저장하고자 하는 것의 본성을 변형시킨다. 위 경우에 한 번에 오직 하나의 `<Panel>`만이 활성화되어야 한다. 이는 공통 부모 컴포넌트가 **어떤** `<Panel>`이 활성화된 것인지 추적해야 한다는 것을 의미한다. 그러므로 불리언 값 대신에 활성화된 `<Panel>`의 인덱스 값을 숫자로 상태 변수에 저장할 수 있을 것이다.

```jsx
const [activeIndex, setActiveIndex] = useState(0);
```

보여주기 버튼을 클릭하면 `<Accordion>`의 `activeIndex`가 변경되어야 한다. `activeIndex`는 `<Accordion>`에서 정의되었으므로 `<Panel>`이 직접적으로 `activeIndex`를 설정할 수는 없다. 대신 `<Accordion>` 컴포넌트가 이벤트 핸들러를 prop으로 전달하여 `<Panel>` 컴포넌트가 해당 상태를 변경하는 것을 명시적으로 허용해야 한다.

```jsx
<>
  <Panel isActive={activeIndex === 0} onShow={() => setActiveIndex(0)}>
    ...
  </Panel>
  <Panel isActive={activeIndex === 1} onShow={() => setActiveIndex(1)}>
    ...
  </Panel>
</>
```

이제 `<Panel>` 안의 `<button>`은 그것의 클릭 이벤트 핸들러로 `onShow` 함수를 이용할 것이다.

```jsx
import { useState } from "react";

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest
        city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for
        "apple" and is often translated as "full of apples". In fact, the region
        surrounding Almaty is thought to be the ancestral home of the apple, and
        the wild <i lang="la">Malus sieversii</i> is considered a likely
        candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({ title, children, isActive, onShow }) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? <p>{children}</p> : <button onClick={onShow}>Show</button>}
    </section>
  );
}
```

이로써 상태 끌어올리기가 완성된다.

![structure of state that is lifted up](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent_clicked.dark.png&w=1080&q=75)

> > **controlled/uncontrolled components**  
> > 로컬 상태를 갖는 컴포넌트를 "uncontrolled"하다고 부르기도 한다. 가령 `isActive` 상태 변수를 갖는 본래의 `<Panel>` 컴포넌트는 "uncontrolled"하다. 왜냐하면 그것의 부모 컴포넌트가 해당 `<Panel>`이 활성화되어 있는지에 대해 영향을 미칠 수 없기 때문이다.  
> > 반대로 어떤 컴포넌트의 중요 정보가 로컬 상태가 아닌 props라면, 이 컴포넌트를 "controlled"하다고 할 수 있다. 이는 부모 컴포넌트가 해당 컴포넌트의 동작을 완전히 특정하도록 한다. 가령 `isActive` prop을 전달받는 최종적인 `<Panel>` 컴포넌트는 `<Accordion` 컴포넌트에 의해 "제어된다"(controlled).  
> > uncontrolled인 컴포넌트는 조금의 환경설정으로도 쉽게 이용될 수 있다. 하지만 그것들을 조직화하고자 할 때에는 유연성이 떨어질 수 있다. 반면 controlled인 컴포넌트는 최대한으로 유연하게 조직화될 수 있지만, 부모 컴포넌트에서 props를 통해 그 환경이 완전히 설정되어야 한다.  
> > 실전에는 "controlled"와 "uncontrolled"가 엄격한 기술적 용어로 쓰이지는 않는다. 즉 각 컴포넌트에는 일반적으로 로컬 상태와 props가 혼재한다. 그러나 컴포넌트가 어떻게 디자인되어 있고 어떤 기능을 수행 가능한지에 대해서 얘기할 때에는 해당 용어가 유용하게 쓰일 수 있다.  
> > 컴포넌트를 작성할 때 컴포넌트의 어떤 정보가 (props를 통해) controlled여야 하고, 어떤 정보가 (상태를 통해) uncontrolled여야 하는지 고려해야 하겠지만, 언제든 이를 변경하고 리팩터링 할 수도 있다.

### 각 상태에 대한 single source of truth

리액트 어플리케이션에서는 많은 컴포넌트가 각자의 고유한 상태를 갖는다. 어떤 상태는 인풋과 같은 수준의 리프 컴포넌트에 가까이 "살"(live) 것이고, 어떤 상태는 앱 최상단에 가깝게 "살" 것이다.

**각각의 고유한 상태 조각에 대하여 어떤 컴포넌트가 그것을 "소유할" 것인지 선택**하게 될 것인데, 이러한 원칙은 **"single source of truth"를 가져야 한다**는 표현으로도 알려져 있다. 이는 모든 상태가 한 공간에 살아야 한다는 게 아니라, **각각의** 상태 조각들에 대하여 해당 정보의 조각을 보유하는 **특정한** 컴포넌트가 있어야 한다는 것을 의미한다. 컴포넌트 간에 공유되는 상태를 중복하여 선언하는 대신에 이를 공통 부모로 **끌어올리고**, 이를 필요로 하는 자식들에게 **내려보내는** 것이다.

## 상태의 유지 및 초기화

상태는 컴포넌트 간에 고립되어 존재한다. 리액트는 어떤 상태가 어떤 컴포넌트에 속해야 하는가를 UI 트리 내에서 그것들의 위치에 기반해 추적한다. 그리고 리렌더링 가운데 언제 상태를 유지하고 언제 상태를 초기화할지를 제어할 수 있다.

### 상태는 렌더 트리 내 위치에 묶여있다

리액트는 UI의 컴포넌트 구조를 구성하기 위해 렌더 트리를 구축한다.

컴포넌트에 상태를 부여할 때, 아마 상태가 컴포넌트 안에 "사는" 것으로 생각할 수 있겠으나, 상태는 사실 리액트 내부에서 유지된다. 리액트는 상태의 각 조각을 컴포넌트의 렌더 트리 상의 위치에 따라서 적합한 컴포넌트와 연관시킨다.

가령 오직 하나 존재하는 `<Counter>` 컴포넌트를 두 개의 다른 위치에서 렌더링한다고 생각해보자. 리액트 트리는 아마 다음과 같을 것이다.

![react tree for two counters in different positions](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.dark.png&w=828&q=75)

**각 컴포넌트는 트리 상에서 각각에 고유한 위치에 렌더링된다. 따라서 이들은 두 개의 분리된 `<Counter>`이다.** 일반적으로 리액트를 사용하는 데 있어서 이러한 위치들에 대해 생각할 필요는 없지만, 리액트가 어떻게 동작하는지 이해하는 데에는 도움이 된다.

리액트에서 화면 상의 각 컴포넌트는 완전히 고립된 상태를 갖는다. 가령 두 개의 `<Counter>` 컴포넌트를 연이어 렌더링한다면, 각각은 고유의, 독립적인 `score`, `hover` 상태를 가질 것이다. 따라서 한 카운터가 업데이트 되면 해당 컴포넌트의 상태만이 업데이트 된다.

![preserving state incrementation](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_increment.dark.png&w=1080&q=75)

리액트는 동일한 컴포넌트를 트리 ㅈ구조 상 동일한 위치에 렌더링하는 한은 상태를 유지시킨다. 가령 두 개의 `<Counter>`를 화면에서 제거하면, 해당 컴포넌트의 렌더링이 중지되는 순간 그것의 상태도 완전히 사라지는 것을 보게 된다. 이는 리액트가 컴포넌트를 제거할 때에는 그것의 상태도 함께 파괴하기 때문이다. 그리고 이 컴포넌트를 다시 나타나게 하면, 해당 상태는 초기화되어 DOM에 추가된다.

리액트는 컴포넌트가 UI 트리 내 의도된 위치에서 렌더링되는 동안에만 해당 컴포넌트의 상태를 유지한다. 만약 컴포넌트가 제거된다면, 혹은 동일한 위치에 다른 컴포넌트가 렌더링된다면, 리액트는 해당 상태를 폐기할 것이다.

### 동일 위치의 동일 컴포넌트는 상태를 유지한다

아래 예시에는 두 개의 서로 다른 `<Counter>` 태그가 존재한다.

```jsx
import { useState } from "react";

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = "counter";
  if (hover) {
    className += " hover";
  }
  if (isFancy) {
    className += " fancy";
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

여기서 체크박스를 체크 또는 취소할 때 `<Counter>`의 상태는 초기화되지 않는다. `isFancy`가 `true`이든 `false`이든 상관 없이 `<Counter>`는 루트의 `App` 컴포넌트에서 반환되는 `div` 태그의 첫 번째 자식 요소로 존재한다. 달리 표현하자면 이는 동일 위치에 동일 컴포넌트가 계속해서 존재하는 것으로 리액트의 관점에서 둘을 동일한 `<Counter>`이다.

> > **주의**  
> > 기억해야 할 점은 **리액트에게 중요한 것이, JSX 마크업에서의 위치가 아니라, UI 트리에서의 위치라는 점**이다. 아래 컴포넌트에는 `if` 절 안팎에서 서로 다른 `<Counter>`를 반환하는 `return` 절이 두 개 존재한다.
> >
> > ```jsx
> > import { useState } from "react";
> >
> > export default function App() {
> >   const [isFancy, setIsFancy] = useState(false);
> >   if (isFancy) {
> >     return (
> >       <div>
> >         <Counter isFancy={true} />
> >         <label>
> >           <input
> >             type="checkbox"
> >             checked={isFancy}
> >             onChange={(e) => {
> >               setIsFancy(e.target.checked);
> >             }}
> >           />
> >           Use fancy styling
> >         </label>
> >       </div>
> >     );
> >   }
> >   return (
> >     <div>
> >       <Counter isFancy={false} />
> >       <label>
> >         <input
> >           type="checkbox"
> >           checked={isFancy}
> >           onChange={(e) => {
> >             setIsFancy(e.target.checked);
> >           }}
> >         />
> >         Use fancy styling
> >       </label>
> >     </div>
> >   );
> > }
> >
> > function Counter({ isFancy }) {
> >   const [score, setScore] = useState(0);
> >   const [hover, setHover] = useState(false);
> >
> >   let className = "counter";
> >   if (hover) {
> >     className += " hover";
> >   }
> >   if (isFancy) {
> >     className += " fancy";
> >   }
> >
> >   return (
> >     <div
> >       className={className}
> >       onPointerEnter={() => setHover(true)}
> >       onPointerLeave={() => setHover(false)}
> >     >
> >       <h1>{score}</h1>
> >       <button onClick={() => setScore(score + 1)}>Add one</button>
> >     </div>
> >   );
> > }
> > ```
> >
> > 체크박스를 체크할 때 상태가 초기화될 것이라 생각할 수 있겠지만, 실상은 그렇지 않은데, 이는 **위 `<Counter>` 태그가 모두 동일한 위치에 렌더링되기 때문**이다. 리액트는 함수의 조건문들이 어디에 위치하는지 알지 못하며, 오직 어떤 트리가 반환되는가만을 "본다".  
> > 두 경우 모두에서 `App` 컴포넌트는 `Counter`를 첫 번째 자식으로 갖는 `<div>` 태그를 반환한다. 리액트에게 있어서 이 두 `<Counter>`는 동일한 "주소", 즉 루트의 첫 번째 자식의 첫 번째 자식이라는 주소를 갖는 것이다. 이것이 리액트가 로직의 구축 방식과는 상관 없이, 전후의 렌더링 사이에서 이들을 매치시키는 방법이다.

### 동일 위치의 다른 컴포넌트는 상태를 초기화한다

아래 예시에서는 체크 박스를 체크하면 `<Counter>`가 `<p>` 태그로 대체된다.

```jsx
import { useState } from "react";

export default function App() {
  const [isPaused, setIsPaused] = useState(false);
  return (
    <div>
      {isPaused ? <p>See you later!</p> : <Counter />}
      <label>
        <input
          type="checkbox"
          checked={isPaused}
          onChange={(e) => {
            setIsPaused(e.target.checked);
          }}
        />
        Take a break
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = "counter";
  if (hover) {
    className += " hover";
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

이때 동일한 위치에서 **서로 다른** 컴포넌트 타입 간의 변경이 이루어진다. 초기에는 `<div>`의 첫 번째 자식이 `<Counter>`를 포함하지만, 이를 `<p>`로 바꾸면, 리액트는 UI 트리에서 `<Counter>`를 제거하고 그 상태를 폐기한다.

![no state preservation between different components](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt1.dark.png&w=1920&q=75)

또한 **동일한 위치에 다른 컴포넌트를 렌더링하면 제거된 컴포넌트의 모든 서브트리의 상태들도 초기화된다.**

```jsx
import { useState } from "react";

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <div>
          <Counter isFancy={true} />
        </div>
      ) : (
        <section>
          <Counter isFancy={false} />
        </section>
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={(e) => {
            setIsFancy(e.target.checked);
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = "counter";
  if (hover) {
    className += " hover";
  }
  if (isFancy) {
    className += " fancy";
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

여기서 체크박스를 체크하면 `<Counter>`의 상태가 초기화된다. `<Counter>`를 렌더링하고는 있지만 최상단 `<div>`의 첫 번째 자식이 `<div>`에서 `<section>`으로 변경되었기 때문이다. DOM에서 자식 `<div>`가 제거되면 그 아래의 모든 트리 또한 파괴되는 것이다.

![states in subtrees of different components are not preserved](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.dark.png&w=1920&q=75)

> > **주의**  
> > 이는 컴포넌트 함수 정의를 네스팅하면 안 되는 이유이기도 하다. 아래 예시에서는 `MyTextField` 컴포넌트 함수가 `MyComponent` 컴포넌트 함수 **내부에서** 정의되어 있다.
> >
> > ```jsx
> > import { useState } from "react";
> >
> > export default function MyComponent() {
> >   const [counter, setCounter] = useState(0);
> >
> >   function MyTextField() {
> >     const [text, setText] = useState("");
> >
> >     return <input value={text} onChange={(e) => setText(e.target.value)} />;
> >   }
> >
> >   return (
> >     <>
> >       <MyTextField />
> >       <button
> >         onClick={() => {
> >           setCounter(counter + 1);
> >         }}
> >       >
> >         Clicked {counter} times
> >       </button>
> >     </>
> >   );
> > }
> > ```
> >
> > 여기서는 버튼을 클릭할 때마다 인풋의 상태가 사라져버린다. 이는 `<MyComponent>`가 렌더링될 때마다 새로운 `MyTextField` 함수가 생성되기 때문이다. 동일한 위치에 **다른** 컴포넌트를 렌더링하고 있으므로 리액트는 그 아래의 모든 상태를 초기화한다. 이러한 문제를 방지하기 위해서는 **항상 최상위에서 컴포넌트 함수를 선언하고 그 정의를 네스팅하지 말아야 한다.**

### 동일 위치에서 상태 초기화하기

디폴트로 리액트는 컴포넌트가 동일 위치에 머무르는 한은 그 상태를 유지한다. 그러나 어떤 경우에는 컴포넌트의 상태를 초기화하기를 원할 수도 있다.

```jsx
import { useState } from "react";

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? <Counter person="Taylor" /> : <Counter person="Sarah" />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = "counter";
  if (hover) {
    className += " hover";
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>
        {person}'s score: {score}
      </h1>
      <button onClick={() => setScore(score + 1)}>Add one</button>
    </div>
  );
}
```

위 예시에서는 현재 플레이어를 변경할 때 기존의 `score`는 유지된다. 두 개의 `<Counter>` 컴포넌트는 동일한 위치에 나타나므로 리액트는 이들을 `person` prop만이 변경된 동일한 `<Counter>`로 간주한다.

하지만 개념적으로 볼 때 이 앱에서 이들은 상호 분리된 `<Counter>`여야 한다. 이들은 UI 상에서 동일한 위치에 나타나기는 하겠지만, 하나는 Taylor의 카운터이고, 하나는 Sarah의 카운터이다.

이들 간에 컴포넌트를 변경할 때에도 상태를 초기화하는 데에는 두 가지 방법이 있다:

1. 컴포넌트를 서로 다른 위치에 렌더링한다.
2. `key`를 이용해 각 컴포넌트에 명시적인 아이덴티티를 부여한다.

#### 옵션 1. 컴포넌트를 다른 위치에 렌더링하기

두 `<Counter>`가 각자 독립적이기를 원한다면 이들을 서로 다른 위치에 렌더링할 수 있다.

```jsx
import { useState } from "react";

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA && <Counter person="Taylor" />}
      {!isPlayerA && <Counter person="Sarah" />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}

// …
```

- 초기 렌더링 시 `isPlayerA`는 `true`이다. 따라서 첫 번째 위치는 `<Counter>`와 그 상태를 가지며, 두 번째 위치는 빈 공간이다.
- "Next player!" 버튼을 누르면 첫 번째 위치가 비어지고 두 번째 위치가 `<Counter>`를 포함하게 된다.

각 `<Counter>`의 상태는 해당 `<Counter>`가 DOM에서 제거될 때마다 함께 파괴된다. 이것이 버튼을 클릭할 때마다 상태가 초기화되는 이유이다.

이는 동일한 공간에 적은 수의 독립적인 컴포넌트만이 존재할 때 편리한 해결방법일 수 있다.

#### 옵션 2. `key`를 이용해 상태 초기화하기

보다 일반적인 방법으로 컴포넌트의 상태를 초기화할 수도 있다.

리스트를 렌더링 할 때 `key`를 본 적이 있을텐데, `key`는 리스트만을 위해 존재하는 것이 아니다. `key`는 리액트가 어떤 유형의 컴포넌트이든 구별할 수 있도록 만드는 데 사용 가능하다. 디폴트로 리액트는 부모 내의 순서를 이용하여 컴포넌트를 구별한다. 하지만 `key`를 사용하면 리액트는 어떤 `<Counter>`가 단지 첫 번째 혹은 두 번째 `<Counter>`인지를 알게되는 것이 아니라, 어떤 특정한 `<Counter>`임을 알게 된다. 이 경우 리액트는 트리 내의 어떤 곳에서든 Taylor의 `<Counter>`를 식별할 수 있게 된다.

```javascript
{
  isPlayerA ? (
    <Counter key="Taylor" person="Taylor" />
  ) : (
    <Counter key="Sarah" person="Sarah" />
  );
}
```

Taylor와 Sarah 사이를 오가는 일은 이제 상태를 유지하지 않는다. 이는 **해당 컴포넌트들에 서로 다른 `key`를 부여했기 때문**이다.

## 리듀서에 상태 로직 부여하기

많은 상태 업데이트가 다수의 이벤트 핸들러에 걸쳐 일어나는 컴포넌트 함수를 작성하는 것은 어려운 일이다. 이러한 경우 모든 상태 업데이트 로직을 컴포넌트 바깥의 하나의 함수, 즉 리듀서에 통합해볼 수 있다.

### 상태 로직을 리듀서에 통합하기

컴포넌트의 복잡도가 커질수록 컴포넌트 상태를 업데이트하는 여러 방법들을 한눈에 보기 어려워진다. 가령 아래 `<TaskApp>` 컴포넌트는 `tasks`라는 배열을 상태로 가지며, 이를 추가, 제거, 수정하기 위해 세 가지 서로 다른 이벤트 핸들러를 사용한다.

```jsx
import { useState } from "react";
import AddTask from "./AddTask.js";
import TaskList from "./TaskList.js";

export default function TaskApp() {
  const [tasks, setTasks] = useState(initialTasks);

  function handleAddTask(text) {
    setTasks([
      ...tasks,
      {
        id: nextId++,
        text: text,
        done: false,
      },
    ]);
  }

  function handleChangeTask(task) {
    setTasks(
      tasks.map((t) => {
        if (t.id === task.id) {
          return task;
        } else {
          return t;
        }
      })
    );
  }

  function handleDeleteTask(taskId) {
    setTasks(tasks.filter((t) => t.id !== taskId));
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: "Visit Kafka Museum", done: true },
  { id: 1, text: "Watch a puppet show", done: false },
  { id: 2, text: "Lennon Wall pic", done: false },
];
```

각 이벤트 핸들러는 상태를 업데이트하기 위해 `setTasks`를 호출한다. 컴포넌트가 커질수록 상태 로직의 양 또한 많아진다. 이러한 복잡도를 줄이고 모든 로직을 하나의 장소에서 쉽게 다룰 수 있도록 하기 위해 이 상태 로직을 컴포넌트 바깥의 단일 함수, 즉 **리듀서**(reducer)로 옮길 수 있다.

리듀서는 상태를 다루는 또 다른 방법이며, 세 단계에 걸쳐 `useState`에서 `useReducer`로 이동할 수 있다:

1. 상태의 세팅에서 액션의 디스패칭으로 **이동한다**.
2. 리듀서 함수를 **작성한다**.
3. 컴포넌트에서 리듀서를 **이용한다**.

### 스텝 1. 상태의 세팅에서 액션의 디스패칭으로 이동

현재 이벤트 핸들러는 아마 상태 세터 함수를 이용해 **무엇을 할 것인지**를 명확히 하고 있을 것이다.

```javascript
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    })
  );
}

function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
```

여기서 모든 상태 세팅 로직을 제거하면 세 개의 이벤트 핸들러가 남는다.

- `handleAddTask(text)` : 유저가 "Add" 버튼을 클릭하면 호출된다.
- `handleChangeTask(task)` : 유저가 `task`를 껐다 켜거나 "Save" 버튼을 누르면 호출된다.
- `handleDeleteTask(taskId)` : 유저가 "Delete" 버튼을 누르면 호출된다.

리듀서로 상태를 관리하는 것은 직접적으로 상태를 세팅하는 것과 약간의 차이를 보인다. 상태를 세팅함으로써 리액트에게 "무엇을 할 것인지" 말하는 대신에, 이벤트 핸들러에서 "액션"을 디스패칭(전송)함으로써 "유저가 방금 무엇을 했는지" 특정하는 것이다.

```javascript
function handleAddTask(text) {
  dispatch({
    type: "added",
    id: nextId++,
    text: text,
  });
}

function handleChangeTask(task) {
  dispatch({
    type: "changed",
    task: task,
  });
}

function handleDeleteTask(taskId) {
  dispatch({
    type: "deleted",
    id: taskId,
  });
}
```

여기서 `dispatch`에 전달한 객체를 "액션"이라고 부른다. 액션은 일반적인 자바스크립트 객체이다. 이러한 액션에 무엇을 집어넣을 것인지를 결정하면 되는데, 일반적으로 액션은 **어떤 일이 일어났는지**에 대한 최소한의 정보를 포함해야 한다.

> 액션 객체는 어떤 형태이든 취할 수 있다. 가장 일반적인 컨벤션은 어떤 일이 일어났는지 설명하는 문자열 `type`을 포함하여 다른 부가적인 정보를 함께 전달하는 것이다.
>
> ```javascript
> dispatch({
>   // specific to component
>   type: "what_happened",
>   // other fields go here
> });
> ```

### 스텝 2. 리듀서 함수 작성

리듀서 함수는 상태 로직을 집어넣을 공간이다. 리듀서 함수는 두 개의 인자를 받는데, 하나는 현재 상태이고, 다른 하나는 액션 객체이다. 리듀서 함수의 반환 값은 다음 상태 값이다.

```javascript
function myReducer(state, action) {
  // 다음 상태를 반환
}
```

리액트는 리듀서에서 반환한 값으로 상태를 세팅할 것이다.

상태 세팅 로직을 이벤트 핸들러에서 리듀서 함수로 이동시키기 위해 위 예시에서는:

1. 현재 상태(`tasks`)를 첫 번째 인자로 선언한다.
2. 액션 객체를 두 번째 인자로 선언한다.
3. 리듀서로부터 **다음** 상태를 반환한다.

```javascript
function tasksReducer(tasks, action) {
  if (action.type === "added") {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === "changed") {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === "deleted") {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error("Unknown action: " + action.type);
  }
}
```

리듀서가 상태(`tasks`)를 인자로 취하기 때문에 **리듀서 함수는 컴포넌트의 바깥에서 선언할 수 있다**. 이는 들여쓰기 정도를 줄이고 코드를 읽기 쉽게 할 수 있다.

> 위 코드는 `if`/`else` 문을 사용하지만, 리듀서 안에서는 `switch` 문을 사용하는 것이 일반적이다. 결과는 같지만 `switch` 문을 사용하면 코드를 한눈에 읽기 쉽게 만들 수 있다.
>
> ```javascript
> function tasksReducer(tasks, action) {
>   switch (action.type) {
>     case "added": {
>       return [
>         ...tasks,
>         {
>           id: action.id,
>           text: action.text,
>           done: false,
>         },
>       ];
>     }
>     case "changed": {
>       return tasks.map((t) => {
>         if (t.id === action.task.id) {
>           return action.task;
>         } else {
>           return t;
>         }
>       });
>     }
>     case "deleted": {
>       return tasks.filter((t) => t.id !== action.id);
>     }
>     default: {
>       throw Error("Unknown action: " + action.type);
>     }
>   }
> }
> ```
>
> 각 `case` 블록을 중괄호로 감싸서 서로 다른 `case` 내에서 선언된 변수들이 서로 충돌하지 않도록 하는 것이 좋다. 또한 하나의 `case`는 보통의 경우 `return`과 함께 끝나야 한다. `return`을 생략하면 코드가 다음 `case`로 넘어가게 되는데, 이는 실수를 야기할 수 있다.

### 스텝 3. 컴포넌트에서 리듀서 이용

마지막으로, `tasksReducer`를 컴포넌트에 연결해야 한다. 우선 리액트에서 `useReducer`를 import한다.

```javascript
import { useReducer } from "react";
```

그런 후 `useState`를 `useReducer`로 대체한다.

```javascript
const [tasks, setTasks] = useState(initialTasks);

const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

`useReducer` 훅은 `useState`와 유사하다. 초기 상태를 훅에 전달해야 하며, 훅은 stateful인 값과 상태를 세팅할 디스패치 함수를 반환한다.

그러나 약간의 차이점도 존재한다. `useReducer` 훅은 두 개의 인자를 받고:

1. 리듀서 함수
2. 초기 상태

두 가지를 반환한다:

1. stateful인 값
2. 디스패치 함수 (유저의 액션을 리듀서로 디스패치하는 함수)

### `useState`와 `useReducer` 비교하기

물론 리듀서에 단점이 없는 것은 아니다. 아래 기준들을 통해 `useReducer`와 `useState`를 비교해볼 수 있다.

- 코드 사이즈 : 일반적으로 `useState`를 사용하면 사전에 더 적은 코드를 적게 된다. `useReducer`를 사용하면 리듀서 함수와 디스패치 액션을 **모두** 작성해야 한다. 하지만 다수의 이벤트 핸들러가 유사한 방식으로 상태를 변경하는 경우에는 `useReducer`가 코드의 양을 줄일 수 있다.
- 가독성 : 상태 업데이트가 단순하다면 `useState`가 매우 쉽게 읽힐 것이다. 그러나 상태 업데이트가 보다 복잡해지면 그로 인해 컴포넌트의 코드가 비대해지고 한눈에 스캔하기 어려워진다.
- 디버깅 : `useState`를 사용하다 버그가 발생하면 **어디에서**, 그리고 **왜** 상태가 잘못 세팅되었는지 말하기 어려울 수 있다. `useReducer`를 사용하면 리듀서에 콘솔 로그를 추가하여 모든 상태 업데이트를, 그리고 **왜** 해당 업데이트가 일어났는지를 눈으로 확인할 수 있다. 만약 각 액션이 올바르다면, 리듀서 로직 자체에 실수가 있었음을 알게 될 것이다. 그러나 `useState`에서보다는 더 많은 코드를 작성해야 한다.
- 테스팅 : 리듀서는 순수한 함수로서 컴포넌트에 의존하지 않는다. 이는 리듀서 함수를 분리하여 export하거나 테스트할 수 있음을 의미한다. 일반적으로는 실제에 가까운 환경에서 컴포넌트를 테스트하는 것이 좋지만, 복잡한 상태 업데이트 로직의 경우 리듀서가 특정 초기 상태 및 액션에 대해 특정 상태를 반환하는 바를 확인하는 것이 유용할 수 있다.
- 개인적 선호도 : 리듀서를 좋아하거나 싫어하는 것은 사실 개인에게 달려있기도 하다. `useState`와 `useReducer`는 사실상 동등하므로 둘 사이를 언제든 왔다갔다 할 수 있다.

몇몇 컴포넌트에서 잘못된 상태 업데이트로 인한 버그를 자주 맞닥뜨린다면 리듀서를 사용하는 것이 좋다. 그렇다고 모든 것에 리듀서를 사용할 필요는 없으며, 심지어 하나의 컴포넌트 안에서 `useState`와 `useReducer`를 혼용하는 것도 가능하다.

### 리듀서 잘 작성하기

- **리듀서는 반드시 순수해야 한다.** 상태 업데이트 함수와 유사하게 리듀서는 렌더링 중에 작동한다(액션은 다음 렌더링이 일어날 때까지 큐로 쌓인다). 이는 리듀서가 순수해야 한다는 것을, 즉 동일 인풋에 대해 항상 동일한 아웃풋을 내야 한다는 것을 의미한다. 따라서 리듀서는 리퀘스트를 보내거나 타임아웃을 설정해서는 안 되며, 어떤 사이드 이팩트도 수행해서는 안 된다(컴포넌트 바깥의 것들에 영향을 미치는 작업 등). 리듀서는 뮤테이션 없이 객체 및 배열을 업데이트해야 한다.
- **각 액션은 하나의 유저 상호작용을 묘사한다. 그것이 데이터에 여러 변화를 일으키는 경우에도 말이다.** 예를 들어 한 유저가 리듀서에 의해 관리되는 다섯 개의 필드를 갖는 폼 안의 리셋 버튼을 누른다고 가정하면, 다섯 개의 개별적인 `set_field` 액션을 디스패치하는 것보다는 하나의 `reset_form` 액션을 디스패치하는 것이 더 합리적일 것이다.

## 컨텍스트를 이용해 데이터를 깊이 전달하기

보통의 경우 props를 통해 부모 컴포넌트에서 자식 컴포넌트로 정보를 전달한다. 그러나 만약 중간의 여러 컴포넌트를 통해서 정보를 전달해야 한다거나, 앱 내 많은 컴포넌트들이 동일한 정보를 필요로 한다면, props를 이용한 정보전달은 동어반복적이고 불편한 일이 될 것이다. **컨텍스트**는 하부 트리의 어떤 컴포넌트에든 정보를 props 없이 깊이 전달할 수 있도록 한다.

### props 전달의 문제점

props 전달은 UI 트리를 통하여 해당 정보를 이용하는 컴포넌트로 데이터를 명시적으로 전달하는 훌륭한 방법이다.

그러나 어떤 prop을 트리 상 깊이 전달해야 한다거나 다수의 컴포넌트가 동일한 prop을 필요로 하는 경우 동어반복적이고 불편하게 될 수 있다. 가장 가까운 공통 조상이 데이터를 필요로 하는 컴포넌트와 동떨어질 수 있고, 그 정도 높이로 상태를 끌어올리는 일은 "prop 드릴링"이라 불리는 상황을 야기할 수 있다.

![prop drilling](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_prop_drilling.dark.png&w=1920&q=75)

리액트의 컨텍스트는 이러한 props 전달 없이 데이터를 특정 컴포넌트로 "순간이동"시키는 일을 해낼 수 있다.

### 컨텍스트 : props 전달의 대안

컨텍스트는 부모 컴포넌트로 하여금 그 아래의 전체 트리로 데이터를 제공할 수 있게 한다. 가령 `level` 데이터를 받아 사이즈를 설정하는 `<Heading>` 컴포넌트를 생각해보자. 이때 `<Heading>`들은 동일 `<Section>` 내에서는 동일한 크기를 가져야 한다.

```jsx
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Section>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Section>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Section>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

위에서는 `level` prop을 각 `<Heading>`에 개별적으로 보내고 있다.

이때 아마 `level` prop을 `<Section>` 컴포넌트로 전달하여 `<Heading>`에는 보낼 필요가 없게 한다면, 동일 섹션 내 모든 `<Heading>`들이 같은 사이즈를 갖도록 할 수 있다.

```jsx
<Section level={3}>
  <Heading>About</Heading>
  <Heading>Photos</Heading>
  <Heading>Videos</Heading>
</Section>
```

그러나 `<Heading>` 컴포넌트는 어떻게 가까운 `<Section>`의 `level`을 알 수 있는가? **여기에는 자식이 트리 위쪽 어딘가에 데이터를 "요청"할 어떤 방법이 필수적이다.**

이는 props만으로는 실현할 수 없으며, 컨텍스트가 필요하다:

1. 컨텍스트를 **생성**한다. (이를 `LevelContext`라 부를 수 있겠다.)
2. 해당 데이터를 필요로 하는 컴포넌트에서 그 컨텍스트를 **이용**한다. (`<Heading>`이 `LevelContext`를 이용하게 된다.)
3. 데이터를 특정하는 컴포넌트에서 그 컨텍스트를 **제공**한다. (`<Section>`이 `LevelContext`를 제공할 것이다.)

컨텍스트는 멀리 떨어진 부모가 어떤 데이터를 그 안의 전체 트리에 제공할 수 있도록 한다.

![passing data with context rather than prop drilling](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_far.dark.png&w=1920&q=75)

#### 스텝 1. 컨텍스트 생성

우선은 컨텍스트를 생성해야 한다. **한 파일로부터 컨텍스트를 export**할 필요가 있으며, 그러면 컴포넌트들이 해당 컨텍스트를 이용할 수 있게 된다.

```javascript
// LevelContext.js
import { createContext } from "react";

export const LevelContext = createContext(1);
```

`createContext`의 유일한 인자는 **디폴트** 값이며, 여기에는 어떤 종류의 값이든 전달할 수 있다.

#### 스텝 2. 컨텍스트 이용

리액트의 `useContext`와 위에서 생성한 컨텍스트를 import한다.

```jsx
import { useContext } from "react";
import { LevelContext } from "./LevelContext.js";
```

현재는 `<Heading>` 컴포넌트가 props로부터 `level`을 읽어들이고 있는데,

```jsx
export default function Heading({ level, children }) {
  // ...
}
```

그렇게 하는 대신에 `level` prop을 제거하고, 위에서 import 한 컨텍스트, `LevelContext`의 값을 읽어들인다.

```jsx
export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}
```

`useContext`는 훅이다. `useState`나 `useReducer`처럼, 훅은 반복문이나 조건문 안에서가 아니라 리액트 컴포넌트 안에서만 호출할 수 있다. `useContext`는 리액트에게 `<Heading>` 컴포넌트가 `LevelContext`를 읽고자 함을 말해준다.

이제 `<Heading>` 컴포넌트는 `level` prop을 갖지 않으며, 아래와 같은 형태로 `level` prop을 JSX 내 `<Heading>`에 전달할 필요도 없다.

```jsx
<Section>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
</Section>
```

아래와 같이 JSX를 수정하면 `level`을 받는 게 `<Section>`으로 변경된다.

```jsx
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

위 예시는 아직 곧잘 작동하지는 않을텐데, 이는 **컨텍스트를 이용하고 있을지라도, 컨텍스트가 제공되지는 않았기 때문**이다. 즉 리액트는 현재 어디에서 해당 컨텍스트를 가져와야 할지 알지 못한다.

#### 스텝 3. 컨텍스트 제공

위 `<Section>` 컴포넌트는 `children`을 렌더링하는데, **`children`을 컨텍스트 프로바이더로 감싸서** 자식들에 `LevelContext`를 제공할 수 있다.

```jsx
import { LevelContext } from "./LevelContext.js";

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>{children}</LevelContext.Provider>
    </section>
  );
}
```

이는 리액트에게 "`<Section>` 내의 어떤 컴포넌트든 `LevelContext`를 요청하면 여기 이 `level` 값을 전달해줘"라고 말하는 것과 같다. 그러면 컴포넌트는 그것보다 위의 UI 트리에서 가장 가까운 `<LevelContext.Provider>`의 값을 이용할 것이다.

```jsx
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

이는 본래 코드와 동일한 결과를 보이지만 각각의 `<Heading>` 컴포넌트에 `level` prop을 전달할 필요가 없다. 대신에 `<Heading>` 컴포넌트는 그것 위의 가장 가까운 `<Section>`에게 물어봄으로써 해당하는 `level`을 "계산해내게"(figure out) 된다:

1. `level` prop을 `<Section>`에 전달한다.
2. `<Section>`은 `children`을 `<LevelContext.Provider value={value}>`로 감싼다.
3. `<Heading>`은 `useContext(LevelContext)`를 호출하여 `LevelContext`의 가장 가까운 값을 묻는다.

### 동일 컴포넌트에서 컨텍스트를 이용하고 제공하기

위에서는 여전히 각 섹션의 `level`을 직접 정해주어야 한다.

컨텍스트는 상위 계층의 컴포넌트로부터 정보를 읽을 수 있도록 하므로, 각 `<Section>`이 그 위의 `<Section>`으로부터 `level`을 읽는 것도, 그리고 아래 계층으로 `level + 1`과 같은 값을 자동으로 전달하도록 하는 것도 가능하다.

```jsx
import { useContext } from "react";
import { LevelContext } from "./LevelContext.js";

export default function Section({ children }) {
  const level = useContext(LevelContext);
  return (
    <section className="section">
      <LevelContext.Provider value={level + 1}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

이로써 `level` prop을 `<Section>`에도, `<Heading>`에도 전달할 필요가 없어졌다.

```jsx
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function Page() {
  return (
    <Section>
      <Heading>Title</Heading>
      <Section>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

이제 `<Heading>`과 `<Section>` 모두 `LevelContext`를 읽어들여 그들 자신이 얼마나 "깊이" 존재하는지 알아챌 수 있다. 그리고 `<Section>`은 `children`을 `LevelContext`로 감쌈으로써 자신 내부의 어떤 것이든 "더 깊은" 레벨에 존재함을 특정하게 된다.

### 사이사이의 컴포넌트를 거치는 컨텍스트 전달

컨텍스트를 제공하고 사용하는 컴포넌트 사이에는 원하는 만큼 많은 컴포넌트를 끼워넣을 수 있다.

```jsx
import Heading from "./Heading.js";
import Section from "./Section.js";

export default function ProfilePage() {
  return (
    <Section>
      <Heading>My Profile</Heading>
      <Post title="Hello traveller!" body="Read about my adventures." />
      <AllPosts />
    </Section>
  );
}

function AllPosts() {
  return (
    <Section>
      <Heading>Posts</Heading>
      <RecentPosts />
    </Section>
  );
}

function RecentPosts() {
  return (
    <Section>
      <Heading>Recent Posts</Heading>
      <Post title="Flavors of Lisbon" body="...those pastéis de nata!" />
      <Post title="Buenos Aires in the rhythm of tango" body="I loved it!" />
    </Section>
  );
}

function Post({ title, body }) {
  return (
    <Section isFancy={true}>
      <Heading>{title}</Heading>
      <p>
        <i>{body}</i>
      </p>
    </Section>
  );
}
```

특별한 일을 하지 않아도 `<Section>`은 그 내부 트리의 컨텍스트를 특정하므로 `<Heading>`을 어디에 삽입하여도 올바른 사이즈의 `<Heading>`이 렌더링된다.

**컨텍스트는 "주변에 적응하여" 어디에 렌더링되었는지, 즉 어떤 컨텍스트를 가지는지에 따라 다르게 나타나는 컴포넌트를 작성할 수 있게 한다.**

컨텍스트의 작동 방식은 CSS 프로퍼티 상속과 유사하다. CSS에서 어떤 `<div>`의 `color: blue`를 특정하면 그 내부의 모든 DOM 노드는 얼마나 깊이 존재하든 간에 해당 값이 중간에 다른 DOM 노드에서 덮어씌워지지 않는 이상 그 색상을 상속한다. 이와 비슷하게 리액트에서 위에서 전달된 컨텍스트로 덮어씌우는 유일한 방법은 `children`을 다른 값을 갖는 컨텍스트 프로바이더로 감싸는 것이다.

또한 **서로 다른 리액트 컨텍스트는 서로의 값을 덮어씌우지 않는다.** `createContext()`로 만든 각 컨텍스트는 서로 완전히 분리되어 있으며, **그 특정한** 컨텍스트를 이용하고 제공하는 컴포넌트들을 한 데 묶는다. 따라서 하나의 컴포넌트가 다수의 서로 다른 컨텍스트를 이용하거나 제공하는 데엔 아무런 문제가 없다.

### 컨텍스트를 이용하기 전에

컨텍스트는 매력적인 만큼 남용되기도 쉽다. **몇 단계에 걸쳐 몇몇 props를 전달해야 한다는 이유만으로 그 정보를 컨텍스트에 넣어서는 안 된다.**

아래는 컨텍스트를 사용하기 전에 고려해볼 수 있는 대안들이다:

1. **props 전달하기에서 시작하기** : 컴포넌트가 어느 정도 중요도를 갖는다면, 다수의 props를 다수의 컴포넌트를 통하여 전달하는 일은 그다지 특별한 게 아니다. 이는 시간이 걸리는 작업처럼 보일 순 있겠지만, 어떤 컴포넌트가 어떤 데이터를 이용하는지를 아주 분명하게 보여준다.
2. **컴포넌트를 따로 빼내어 JSX를 `children`으로 전달하기** : 만약 어떤 데이터를 이를 이용하지 않는 겹겹의 중간 컴포넌트들을 거쳐 전달해야 한다면, 이는 몇몇 컴포넌트를 따로 빼내야 한다는 걸 잊었다는 징조일 수 있다. 예를 들어 `<Layout posts={posts} />`와 같은 형태로 `posts` 같은 데이터 props를 이를 직접적으로 사용하지 않는 시각적 컴포넌트에 전달했을 수 있는데, 이렇게 하는 대신 `<Layout>`이 `children`을 prop으로 취하게 하고, `<Layout><Posts posts={posts} /></Layout>`를 렌더링하여, 데이터를 특정하는 컴포넌트와 데이터를 필요로 하는 컴포넌트 사이의 계층 수를 줄일 수 있다.

만약 위 둘 중 어떤 것도 통하지 않는다면 컨텍스트 사용을 고려해보자.

### 컨텍스트를 사용해볼 유즈케이스

- 테마 입히기
- 현재 계정
- 라우팅 : 대부분의 라우팅 솔루션은 내부적으로 컨텍스트를 이용하여 현 라우트를 붙든다. 이로써 모든 링크가 자신이 활성화되었는지 아닌지를 "계산하게" 된다.
- 상태 관리 : 앱이 커지면 결국 앱의 최상단에 가까운 상태가 많이 존재하게 된다. 멀리 계층 아래에 있는 컴포넌트에서 이 상태들을 변경해야 할텐데, 복잡한 상태를 관리하고 이를 먼 아래의 컴포넌트로 전달하기 위해 리듀서와 컨텍스트를 함께 사용하는 것은 매우 흔한 일이다.

컨텍스트는 정적인 값에 한정되지는 않는다. 만약 다음 렌더링 시점에 다른 값을 전달한다면 리액트는 그 값을 읽는 아래 계층의 모든 컴포넌트들을 업데이트할 것이다. 그렇기에 컨텍스트는 많은 경우 상태와 함께 사용된다.
