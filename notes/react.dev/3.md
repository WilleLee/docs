# 상태 관리하기

어플리케이션이 커질수록 상태를 어떻게 조직화할 것이고 컴포넌트 간의 데이터 흐름은 어떻게 할 것인지에 대해 깊이 생각해봐야 한다. 사용하지 않거나 중복된 상태는 버그의 주된 원인이다. 여기서는 상태를 어떻게 잘 구조화하고, 상태 업데이트 로직을 어떻게 유지 가능하게 하며, 멀리 떨어진 컴포넌트들이 어떻게 상태를 공유하게 할 것인지 살펴볼 것이다.

## 상태를 통해 인풋에 반응하기

리액트는 서술형(declarative)의 방식으로 UI를 조작하게 한다. UI의 개별 요소를 직접적으로 다루는 대신, 컴포넌트가 가질 수 있는 서로 다른 상태들을 묘사하고, 유저 인풋에 반응하여 그러한 상태들 사이를 컴포넌트가 오가게 하는 것이다. 이는 디자이너들이 UI를 생각하는 방식과 유사하다.

### 서술형 UI는 명령형 UI와 어떻게 다른가?

UI의 상호작용을 설계한다고 생각해보면, 아마 유저의 액션에 반응하여 UI가 어떻게 변해야 하는가에 대해 고민하게 될 것이다. 유저가 대답을 제출하도록 하는 `form`에 대해 생각해보자.

1. 인풋에 무언가 입력하면 제출 버튼이 활성화된다.
2. 제출 버튼을 누르면 인풋과 버튼이 비활성화되고 `<Spinner>`가 나타난다.
3. 네트워크 요청이 성공하면 `form`이 가려지고 `"thank you"`라는 메세지가 나타난다.
4. 네트워크 요청이 실패하면 에러 메세지가 나타나고 인풋이 다시 활성화된다.

명령형 프로그래밍(imperative programming)에서는 위의 논리적 플로우가 개발자의 코드의 시행방식과 정확히 일치한다. 발생하는 이벤트에 따라 UI를 조작하는 명확한 지시사항들을 작성해야 하는 것이다. 이런 방식의 UI 프로그래밍에서 `form`은 리액트를 필요로 하지 않으며, 브라우저 DOM만을 이용한다. 이것이 **명령형**이라 불리는 것은 개발자가 각 엘리먼트에게 명령을 전달해야 하기 때문이다.

UI를 명령적으로 조작하는 것은 분리된 예시에서 충분히 잘 작동하지만, 복잡한 시스템에서는 기하급수적으로 관리하기 힘들어진다. **리액트는 이런 문제를 해결하기 위해 만들어졌다.** 리액트에서는 UI를 직접적으로 조작하지 않아도 된다. 대신 **무엇을 보여주고 싶은지 선언**하면 되며, 그러면 리액트는 UI를 어떻게 업데이트할지 계산해낸다.

### 서술적 방식으로 UI에 대해 생각하기

리액트로 생각하는 방법에 대해 이해하기 위해 위의 UI를 리액트로 다시 시행해보자.

1. 컴포넌트의 서로 다른 시각적 상태들을 **확인한다**(identify).
2. 그러한 상태 변화를 촉발하는 것이 무언인지 **결정한다**(determine).
3. `useState`를 이용해 그 상태를 메모리에 **표현한다**(represent).
4. 본질적이지 않은 상태 변수들은 **제거한다**(remove).
5. 이벤트 핸들러들을 **연결하여**(connect) 상태의 업데이트를 구현한다.

#### 스텝 1. 컴포넌트의 서로 다른 시각적 상태들을 확인한다

컴퓨터 과학에서는 몇 가지 상태 가운데 하나가 되는 것을 **상태 머신**(state machine)이라고 한다. 또 디자이너들과 협업하다보면 서로 다른 **시각정 상태**를 표현하는 목업(mockup)을 만들어야 할 때가 있다. 리액트는 디자인과 컴퓨터 과학의 교차 지점에 선다.

우선 유저가 보게 될 UI의 서로 다른 **상태들**을 모두 시각화해야 한다:

- 비어있음 : `<Form>`은 `disabled`인 `<Submit>` 버튼을 갖는다.
- 타이핑 중 : `<Form>`은 `disabled`가 아닌 `<Submit>` 버튼을 갖는다.
- 제출 중 : `<Form>`이 완전히 `disabled`되고 `<Spinner>`가 나타난다.
- 성공 : `<Form>`이 사라지고 `"thank you"`라는 메세지가 나타난다.
- 실패 : 타이핑 중 상태와 동일하지만 부가적인 에러 메세지가 나타난다.

디자이너가 사고하는 바와 같이 리액트 개발자도 로직을 추가하기 전에 서로 다른 상태에 대한 **목업**을 생성하고자 할 것이다. `form`의 시각적 부분만을 보여주는 목업 예시를 살펴보면 이는 `"empty"`를 디폴트 값으로 갖는 `status`라는 prop에 의해 제어된다:

```jsx
export default function Form({ status = "empty" }) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}
```

#### 스텝 2. 그러한 상태 변화를 촉발하는 것이 무언인지 결정한다

상태 업데이트는 두 가지 종류의 인풋에 반응하여 촉발될 수 있다.

- **사람 인풋(human input)** e.g. 버튼 클릭, 타이핑, 링크로 네비게이션 등
- **컴퓨터 인풋(computer input)** e.g. 네트워크 리스펀스의 전달, 타임아웃, 이미지 로딩 등

두 경우 모두에서 **UI를 업데이트하기 위해서는 상태 변수를 설정해야 한다.** 위 `<Form>` 예시를 살펴보자면 아래 몇 가지 인풋에 반응하여 상태를 변화시켜야 할 것이다.

- **텍스트 인풋의 변화**(사람 인풋)는, 텍스트 박스가 비어있는지 아닌지 여부에 따라 `"empty"` 상태를 `"typing"` 상태로 전환시키거나 원래대로 되돌려야 한다.
- `<Submit>` **버튼의 클릭**(사람 인풋)은 `"submitting"` 상태로 전환시켜야 한다.
- **성공적인 네트워크 리스펀스**(컴퓨터 인풋)는 `"success"` 상태로 전환시켜야 한다.
- **실패한 네트워크 리스펀스**(컴퓨터 인풋)는 적절한 에러 메세지와 함께 `"error"` 상태로 전환시켜야 한다.

이러한 플로우를 시각화하기 위해 각 상태를 레이블링된 원으로, 그리고 두 가지 상태 사이에서의 변화를 화살표로 그려보면 로직을 실제 실행하기 전에 버그를 잡아낼 수 있을 것이다.

![visualizing a flow of state updates](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.dark.png&w=1920&q=75)

#### 스텝 3. `useState`를 이용해 그 상태를 메모리에 표현한다

다음으로는 `useState`를 이용해 메모리에 컴포넌트의 시각적 상태를 표현해야 한다. 여기서는 단순성을 추구해야 하는데, 상태의 각 조각이 "움직이는 조각"이라면 가능한 한 적은 수의 "움직이는 조각들"을 표현해야 할 것이다.

우선 **반드시 존재해야만 하는** 상태로 시작해야 한다(e.g. `answer`, `error`). 그러고 나서는 나타내고자 하는 시각적 상태들 중 하나를 표현하는 상태 변수가 필요할 것이다. 이를 메모리에 표현하는 데에는 하나 이상의 방법이 있겠으나, 최고의 방법이 떠오르지 않는다면 우선은 모든 가능한 시각적 상태를 다룬다고 **확인이 들 정도의** 충분한 수의 상태를 추가하는 데에서 시작하고 추후 리팩터링해가면 된다.

```jsx
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

#### 스텝 4. 본질적이지 않은 상태 변수들은 제거한다

상태 구조를 리팩터링하는 데 시간을 들이는 일은 컴포넌트를 읽기 쉽게 하고, 상태의 중복을 줄이며, 의도되지 않은 요소들을 피하게 한다. 여기서 중점적인 지향점은 **유저가 보기를 원하는 어떤 UI도 표현하지 않는 상태가 메모리에 존재하는 경우를 방지하는 것**이다.

이때 아래와 같은 질문들을 던져볼 수 있을 것이다:

- **이 상태가 역설을 낳을 수도 있는가?**  
  가령 `isTyping`과 `isSubmitting`은 동시에 `true`일 수 없다. 역설은 일반적으로 상태가 충분히 제한되지 않은 경우를 의미한다. 두 개의 불리언 값은 네 가지 가능한 조합을 만들겠지만, 이때 유의미한 상태는 오직 세 가지이다. "불가능한" 상태를 제거하기 위해 이들을 `status`라는 상태로 묶어 `"typing"`, `"submitting"`, `"success"` 중 하나만을 표현하도록 할 수 있다.
- **동일한 정보가 다른 상태 변수에 의해 이미 표현될 수 있는가?**  
  또 다른 역설은 `isEmpty`와 `isTyping`이 동시에 `true`일 수 없다는 것이다. 이들을 분리된 상태 변수로 만듦으로써 이들이 동기화되지 않고 버그 발생의 리스크를 안게 되는 것이다. 다행히 `isEmpty`를 제거하고 `answer.length === 0` 표현문을 이용해 `isTyping`을 대신할 수 있다.
- **다른 상태의 반대값을 통해 동일한 정보를 얻을 수 있는가?**  
  `error !== null`을 체크할 수 있기 때문에 `isError`는 불필요하다.

이런 과정을 거치면 본질적인 상태 변수 세 가지가 남게 된다.

```jsx
const [answer, setAnswer] = useState("");
const [error, setError] = useState(null);
const [status, setStatus] = useState("typing"); // "typing", "submitting", or "success"
```

> > **리듀서를 이용해 "불필요한" 상태 제거하기**  
> > 위 세 가지 변수는 `form`의 상태를 표현하는 데 충분하긴 하지만, 여전히 사이사이의 표현되지 않는 상태들이 존재하기는 한다. 가령 `null`이 아닌 `error`는 `status`가 `"success"`인 경우 성립하지 않는다. 상태를 보다 정확하게 형상화하기 위해서는 이를 리듀서에 넣어볼 수 있을 것이다. 리듀서는 다양한 상태 변수를 하나의 객체로 합치고 모든 연관된 로직들을 통합하도록 한다.

#### 스텝 5. 이벤트 핸들러들을 연결하여 상태의 업데이트를 구현한다

끝으로 상태를 업데이트하는 이벤트 핸들러를 생성하면 된다.

```jsx
import { useState } from "react";

export default function Form() {
  const [answer, setAnswer] = useState("");
  const [error, setError] = useState(null);
  const [status, setStatus] = useState("typing");

  if (status === "success") {
    return <h1>That's right!</h1>;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus("submitting");
    try {
      await submitForm(answer);
      setStatus("success");
    } catch (err) {
      setStatus("typing");
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === "submitting"}
        />
        <br />
        <button disabled={answer.length === 0 || status === "submitting"}>
          Submit
        </button>
        {error !== null && <p className="Error">{error.message}</p>}
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== "lima";
      if (shouldError) {
        reject(new Error("Good guess but a wrong answer. Try again!"));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```
