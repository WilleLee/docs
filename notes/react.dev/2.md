# 상호성 더하기

리액트에서 시간에 따라 변화하는 데이터를 state라고 한다. state는 어떤 컴포넌트에든 추가될 수 있고, 필요에 따라 업데이트 될 수도 있다. 여기서는 상호작용을 핸들링하고 state를 업데이트 하며 시간 별로 상이한 아웃풋을 화면에 나타내는 컴포넌트를 작성하는 법을 배울 것이다.

## 이벤트에 반응하기

리액트는 JSX에 이벤트 핸들러를 추가할 수 있도록 한다. 이때 이벤트 핸들러란 유저 상호작용에 의해 촉발되는 함수를 의미한다.

### 이벤트 핸들러 추가하기

이벤트 핸들러를 추가하기 위해서는

1. 함수를 정의하고,
2. 이를 적절한 JSX 태그에 prop으로 전달하면 된다.

이때 이벤트 핸들러 함수는 보통 컴포넌트 **안에서** 정의되며, handle로 시작하고 event 이름으로 끝나는 명명 컨벤션을 따른다. e.g. `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`

> > 주의  
> > 이벤트 핸들러 함수는 호출되는 것이 아니라 전달되어야 한다. 그렇지 않으면 함수가 렌더링 과정에서 즉시 실행되어 버린다(이벤트 촉발 시가 아니라). 이는 JSX 내의 자바스크립트 코드가 즉시 실행되는 것과 같은 원리이다.

### 이벤트 핸들러에서 props 읽기

컴포넌트 안에서 선언되기 때문에 이벤트 핸들러는 컴포넌트의 props에도 접근할 수 있다.

### 이벤트 핸들러 props 명명하기

`<button>`, `<div>` 같은 빌트인 컴포넌트는 `onClick`처럼 브라우저 이벤트 네임만을 지원한다. 그러나 커스텀 컴포넌트를 만들 때에는 원하는대로 이벤트 핸들러 props의 이름을 정할 수 있다. 이때 이벤트 핸들러 이름을 "on"으로 시작하여 대문자로 이어지게 하는 것이 네이밍 컨벤션이다.

### 이벤트의 Propagation

이벤트 핸들러는 컴포넌트 내 모든 자식 컴포넌트의 이벤트 또한 캐치한다. 이를 이벤트가 트리 위로 "bubble up" 또는 "propagate up"한다고 말한다. 이는 이벤트가 발생한 곳에서 시작하여 트리 위로 올라간다. 리액트에서는 `onScroll`을 제외한 모든 이벤트가 propagation 한다.

### Propagation 막기

이벤트 핸들러는 **이벤트 객체**만을 인자로 전달받으며, 이는 컨벤션 상 "event"를 의미하는 `e`로 불린다. 이 이벤트 객체의 `e.stopPropagation()` 매서드를 호출하면 이벤트가 부모 컴포넌트로 접근하는 것을 방지할 수 있다.

### 핸들러를 propagation의 대안으로 전달하기

```javascript
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}
```

부모로부터 전달받은 이벤트 핸들러, 가령 위의 `onClick` 함수를 호출하기 이전에 더 많은 코드를 핸들러에 추가할 수 있다. 이러한 패턴은, 부모 컴포넌트가 몇몇 추가 동작을 정의하도록 허용하는 것과 동시에 propagation에 대한 하나의 **대안**을 제공한다.

### 디폴트 동작 막기

브라우저의 몇몇 이벤트는 디폴트 동작을 갖는다. 가령 `<form>`의 `submit` 이벤트는 페이지를 새로고침한다. 이러한 디폴트 동작을 막기 위해서는 이벤트 핸들러에서 `e.preventDefault()`를 호출하면 된다.

### 이벤트 핸들러는 사이드 이팩트를 가질 수 있다.

렌더링 함수들과 달리 이벤트 핸들러는 순수할 필요가 없으므로 이벤트 핸들러를 통해 무언가 변화시킬 수 있다. 하지만 몇몇 정보들을 변경하기 위해서는 우선 이를 저장할 무언가가 필요하다. 이러한 일을 리액트에서는 각 컴포넌트의 메모리 역할을 하는 **state**가 수행한다.
