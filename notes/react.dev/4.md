# 비상구

어떤 컴포넌트는 리액트 바깥의 시스템을 제어하거나 거기에 동기화해야 할 수 있다. 가령 브라우저 API를 이용해 인풋을 포커스한다든지, 리액트 없이 구현된 비디오 플레이어를 플레이 또는 중지한다든지, 원격 서버로부터의 메세지를 연결하는 등의 동작이 필요할 수 있다. 이 챕터에서는 리액트 "바깥으로 나가" 외부 시스템과 연결하도록 할 비상구에 대해 배울 것인데, 어플리케이션의 대부분의 로직 및 데이터 흐름은 이러한 특성에 기대지 말아야 한다.

## ref를 이용하여 값 참조하기

컴포넌트가 어떤 정보를 "기억"하기는 하지만 해당 정보가 새로운 렌더링을 촉발하지는 않기를 바라는 경우 **ref**를 사용할 수 있다.

### 컴포넌트에 ref 추가하기

리액트에서 `useRef` 훅을 import 하여 컴포넌트에 ref를 추가할 수 있다.

```jsx
import { useRef } from "react";
```

컴포넌트 안에서 `useRef` 훅을 호출하고 유일한 인자로 원하는 초기값을 전달한다. 가령 아래에서 ref의 값은 `0`이 된다:

```jsx
const ref = useRef(0);
```

`useRef`는 아래와 같은 객체를 반환한다:

```javascript
{
  current: 0, // useRef에 전달한 값
}
```

`ref.current` 프로퍼티를 통해 위 `ref`의 현재 값에 접근할 수 있다. 이 값은 의도적으로 뮤테이션 가능한데, 즉 해당 값을 읽을 수도, 쓸 수도 있다. 이는 리액트가 추적하지 않는 컴포넌트의 비밀 주머니와 같다.

아래 예시에서는 버튼을 클릭할 때마다 `ref.current`의 값이 증가할 것이다:

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

상태와 같이 ref는 어떤 형태의 값이든, 가령 문자열이든 객체이든 심지어는 함수이든 간에 가리킬 수 있다. 상태와 다른 점은 ref가 읽거나 변형할 수 있는 `current` 프로퍼티를 갖는 일반적인 자바스크립트 객체라는 점이다.

**위 `ref.current` 값이 상승할 때 컴포넌트가 리렌더링되지 않는다는 점**에 주목하자. 상태와 같이 ref는 리렌더링 사이에 유지된다. 그러나 상태의 세팅은 컴포넌트를 리렌더링하는 한편 ref의 변경은 그렇지 않다.

### 예시 : 스톱워치 만들기

ref와 상태를 하나의 컴포넌트에서 함께 사용할 수 있다. 예를 들어 버튼을 클릭하여 시작하거나 멈출 수 있는 스톱워치를 만든다고 해보자. 유저가 "Start" 버튼을 누른 후로 얼마나 지났는지 보여주기 위해서는 언제 시작 버튼이 눌렸는지, 그리고 현재 시간은 무엇인지를 추적할 필요가 있다. **이 정보는 렌더링에 이용되므로 상태에 보관해볼 수 있다.**

```jsx
const [startTime, setStartTime] = useState(null);
const [now, setNow] = useState(null);
```

유저가 시작 버튼을 누르면 10 밀리세컨드마다 시간을 업데이트하기 위해 `setInterval`을 사용한다.

```jsx
import { useState } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    // Start counting.
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      // Update the current time every 10ms.
      setNow(Date.now());
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
    </>
  );
}
```

"Stop" 버튼이 눌릴 때 현재 존재하는 인터벌을 멈춰 `now` 상태 변수의 업데이트를 멈춰야 한다. 이는 `clearInterval`을 호출하여 수행할 수 있는데, 이를 위해 유저가 시작 버튼을 누를 때의 `setInterval` 호출로부터 반환되는 인터벌 ID가 필요하다. 그러므로 인터벌 ID를 어딘가에 보관해야 한다. **이때 인터벌 ID는 렌더링에 사용되지 않으므로 ref에 보관해볼 수 있다.**

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

정보의 한 부분이 렌더링에 이용된다면 상태에 보관하면 되고, 만약 이벤트 핸들러에서만 필요하고 해당 정보의 변경이 리렌더링을 필요로 하지 않는다면 ref를 이용하는 것이 더 효율적일 것이다.

### ref와 상태의 차이점

대부분의 경우에서는 상태를 사용하게 되며, ref는 자주 필요하지는 않은 일종의 "비상구"이다. 아래는 상태와 ref를 비교해본 것이다:

| ref                                                                              | 상태                                                                                                  |
| -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `useRef(initialValue)`는 `{ current: initialValue }`를 반환한다.                 | `useState(initialValue)`는 상태 변수의 현재 값과 상태 세터 함수를 반환한다.<br/>(`[value, setValue]`) |
| 변경 시에도 리렌더링을 촉발하지 않는다.                                          | 변경 시 리렌더링을 촉발한다.                                                                          |
| mutable : `current`의 값을 렌더링 프로세스 바깥에서 변경 및 업데이트 할 수 있다. | immutable : 리렌더링 큐를 쌓기 위해 상태 세터 함수를 이용하여 상태 변수를 변경해야만 한다.            |
| 렌더링 시점에 `current` 값을 읽거나 써서는 안 된다.                              | 언제든지 상태를 읽을 수 있다.<br/>다만 각 렌더링 시점은 변하지 않는 고유한 상태 스냅샷을 갖는다.      |

아래 카운터 버튼 예시는 상태와 함께 구현된다.

```jsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>You clicked {count} times</button>;
}
```

`count`의 값이 화면에 보여지기 때문에 이 경우 상태 값을 이용하는 것이 합리적이다. 카운터의 값이 `setCount()`로 변경되면 리액트는 컴포넌트를 리렌더링하고 스크린은 새로운 `count`를 반영하기 위해 업데이트될 것이다.

만약 이를 ref를 이용해 구현하려 했다면 리액트는 결코 컴포넌트를 리렌더링하지 않을 것이므로 카운터가 변화하는 것을 보지 못할 것이다. 이것이 `ref.current`를 렌더링 시에 읽는 일이 신뢰도 떨어지는 코드로 귀결되는 이유이다.

> **내부적으로 `useRef`는 어떻게 동작하는가?**  
> `useState`와 `useRef` 모두 리액트에 의해 제공되기는 하지만, 원칙적으로 `useRef`는 `useState`의 **위에서** 구현될 수 있다. 가령 리액트 내부에서는 `useRef`가 아래와 같이 구현되어 있다고 상상해볼 수 있다:
>
> ```jsx
> // Inside of React
> function useRef(initialValue) {
>   const [ref, unused] = useState({ current: initialValue });
>   return ref;
> }
> ```
>
> 초기 렌더링 시에 `useRef`는 `{ current: initialValue }`를 반환한다. 이 객체는 리액트에 저장되므로 다음 렌더링 시에 동일한 객체가 반환될 것이다. 이 예시에서 상태 세터가 이용되지 않는다는 점에 유의하자. 이는 불필요한데, 왜냐하면 `useRef`가 항상 동일한 객체를 반환할 필요가 있기 때문이다.

### 언제 ref를 이용해야 할까?

일반적으로 ref는 컴포넌트가 리액트 "바깥으로 나가" 외부 API들, 가령 컴포넌트의 외형에 영향을 주지 않는 브라우저 API와 소통해야 할 때 사용된다. 아래는 이런 몇 안 되는 상황들의 예시이다:

- 타임아웃 ID의 저장
- DOM 엘리먼트의 저장 및 조작
- JSX 계산에는 필요하지 않은 다른 객체들의 저장

만약 컴포넌트가 어떤 값을 저장하는데, 이 값이 렌더링 로직에는 영향을 주지 않는다면 ref를 선택하는 것이 바람직하다.

### 최적의 ref 사용법

아래 원칙들을 따름으로써 보다 예측 가능한 컴포넌트를 만들 수 있다:

- ref를 일종의 비상구처럼 다루기  
  ref는 외부 시스템이나 브라우저 API를 이용할 때 유용하다. 만약 앱의 로직 및 데이터 흐름의 많은 부분이 ref에 의존한다면, 접근 방식에 대해 다시 생각해볼 필요가 있을 것이다.
- 렌더링 중에 `ref.current`를 읽거나 쓰지 않기  
  렌더링 중에 어떤 정보가 필요하다면 ref가 아닌 상태를 이용하자. 리액트는 언제 `ref.current`가 변화하는지 알지 못하므로, 렌더링 중에 `ref.current`를 읽어들이는 일조차도 컴포넌트의 동작을 예측하기 어렵게 할 것이다.

리액트 상태의 한계는 ref에 적용되지 않는다. 가령 상태는 매 렌더링 시에 스냅샷처럼 행동하고 동기적으로 업데이트하지는 않는 반면, ref의 현재 값을 뮤테이션하면 그 값은 그 즉시 변경된다.

```javascript
ref.current = 5;
console.log(ref.current); // 5
```

이는 **ref 자신이 일반 자바스크립트 객체**이며 그와 같이 행동하기 때문이다.

또한 ref를 이용하는 중에는 뮤테이션을 피해야 한다는 걱정을 할 필요가 없다. 뮤테이션 되는 객체가 렌더링에 이용되지 않는 한, 리액트는 ref나 그것의 컨텐츠에 어떤 일이 일어나든 신경쓰지 않는다.

### ref와 DOM

ref로는 어떤 형태의 값이든 가리킬 수 있지만, ref를 이용하는 가장 일반적인 유즈케이스는 DOM 엘리먼트에 접근하는 일이다. 가령 어떤 인풋에 프로그래밍적으로 포커스하기를 원한다면 이는 매우 유용할 것이다. `<div ref={myRef}>`와 같이 ref를 JSX의 `ref` 속성에 전달하면, 리액트는 해당하는 DOM 엘리먼트를 `myRef.current`에 저장할 것이다. 그 엘리먼트가 DOM에서 삭제되는 순간 리액트는 `myRef.current`를 `null`로 업데이트할 것이다.

## ref를 이용해 DOM 조작하기

리액트가 자동으로 DOM을 업데이트하여 렌더링 아웃풋과 일치시키기 때문에 컴포넌트는 대부분의 경우 DOM을 직접 조작할 필요가 없다. 그러나 어떤 경우에는 리액트가 관리하는 DOM 엘리먼트에 대한 접근 권한이 필요할 수 있는데, 가령 특정 노드를 포커스하거나, 거기로 스크롤하거나, 노드의 사이즈 또는 위치를 측정하거나 하는 경우 그렇다. 리액트에 그런 일을 수행할 방법이 내장되어 있지 않기 때문에 이 경우 DOM 노드에 대한 **ref**가 필요하다.

### 노드에 대한 ref 얻기

리액트에 의해 관리되는 DOM 노드에 접근하기 위해서는 우선 `useRef` 훅을 import 해야 한다. 그런 후 이를 이용해 컴포넌트 안에서 ref를 선언한다. 끝으로는 ref를 DOM 노드를 취하고자 하는 JSX 태그에 `ref` 속성으로 전달한다.

```jsx
<div ref={myRef} />
```

`useRef` 훅은 `current`라고 불리는 하나의 프로퍼티를 갖는 객체를 반환한다. 초기에 `myRef.current`는 `null`이다. 리액트가 이 `<div>`에 대한 DOM 노드를 생성하면, 리액트는 이 노드에 대한 참조를 `myRef.current`에 저장한다. 그러면 이벤트 핸들러를 이용해 해당 DOM 노드에 접근할 수 있게 되며, 그에 대해 정의된 빌트인 브라우저 API들을 사용할 수 있게 된다.

```javascript
// 어떤 브라우저 API든 사용할 수 있다. 가령:
myRef.current.scrollIntoView();
```

### 예시 : 텍스트 인풋 포커스하기

아래 예시에서 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이를 구현하기 위해:

1. `useRef` 훅으로 `inputRef`를 선언한다.
2. 이를 `<input ref={inputRef}>` 형태로 전달한다. 이로써 리액트는 **이 `<input>`의 DOM 노드를 `inputRef.current`에 집어넣는다.**
3. `handleClick` 함수에서 `inputRef.current`를 통해 인풋 DOM 노드를 읽고, `inputRef.current.focus()`와 같이 해당 DOM 노드의 `focus()` 매서드를 호출한다.
4. `onClick`을 이용해 `handleClick` 이벤트 핸들러를 `<button>`에 전달한다.

DOM을 조작하는 것이 ref의 가장 일반적인 유즈케이스이긴 하지만, `useRef` 훅은 타이머 ID와 같은, 리액트 바깥의 많은 것들을 보관하는 데 사용될 수 있다. 상태와 유사하게 ref는 렌더링 중에 유지된다. ref는 변경 시 리렌더링을 촉발하지 않는 상태 변수라고 할 수 있겠다.

### 예시 : 특정 엘리먼트로 스크롤하기

하나의 컴포넌트 안에 다수의 ref를 포함시킬 수 있다. 아래 예시에는 세 가지 이미지의 캐러셀이 있다. 각각의 버튼은 해당하는 DOM 노드의 `scrollIntoView()` 브라우저 매서드를 호출하여 이미지를 가운데에 위치시킨다:

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>Tom</button>
        <button onClick={handleScrollToSecondCat}>Maru</button>
        <button onClick={handleScrollToThirdCat}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placekitten.com/g/200/200"
              alt="Tom"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/300/200"
              alt="Maru"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/250/200"
              alt="Jellylorum"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}
```

> `ref` 콜백을 이용하여 ref들의 리스트를 관리하는 방법  
> 위 예시에서는 ref의 수가 사전에 정의되어 있다. 하지만 어떤 경우에는 특정 리스트의 각 아이템에 대한 ref의 선언이 필요하기는 하지만 아이템의 수는 알지 못할 수도 있다. 이때 아래와 같은 로직은 **작동하지 않을 것**이다.
>
> ```jsx
> <ul>
>   {items.map((item) => {
>     // Doesn't work!
>     const ref = useRef(null);
>     return <li ref={ref} />;
>   })}
> </ul>
> ```
>
> 이는 **훅은 반드시 컴포넌트의 최상단에서만 호출되어야** 하기 때문이다. 반복문이나 조건문, `map()` 호출 내부에서는 `useRef`를 호출할 수 없다.  
> 이와 관련해 적용해볼 수 있는 한 가지 방법은 부모 엘리먼트에 대한 하나의 ref를 가져와 `querySelectorAll`과 같은 DOM 조작 매서드를 사용하여 개별적인 자식 노드를 "찾아내는" 것이다. 하지만 이는 다루기 힘들고, DOM 구조가 변한다면 더 이상 작동하지 않을 수 있다.  
> 또 다른 해결 방법은 **`ref` 속성에 함수를 전달**하는 것이다. 이러한 일을 **`ref` 콜백**이라 한다. 리액트는 ref를 설정할 때에는 `ref` 콜백을 DOM 노드와 함께 호출하고, ref를 비울 때에는 `ref` 콜백을 `null`과 함께 호출한다. 이를 통해 어떤 배열이나 Map을 유지할 수 있으며, 어떤 ref에 대해 그것의 인덱스 값이나 특정한 ID를 통해 접근할 수 있게 된다.  
> 아래 예시는 이러한 접근법을 긴 리스트의 임의의 노드로 스콜하는 데 어떻게 이용할 수 있는지 보여준다:
>
> ```jsx
> import { useRef } from "react";
>
> export default function CatFriends() {
>   const itemsRef = useRef(null);
>
>   function scrollToId(itemId) {
>     const map = getMap();
>     const node = map.get(itemId);
>     node.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>       inline: "center",
>     });
>   }
>
>   function getMap() {
>     if (!itemsRef.current) {
>       // Initialize the Map on first usage.
>       itemsRef.current = new Map();
>     }
>     return itemsRef.current;
>   }
>
>   return (
>     <>
>       <nav>
>         <button onClick={() => scrollToId(0)}>Tom</button>
>         <button onClick={() => scrollToId(5)}>Maru</button>
>         <button onClick={() => scrollToId(9)}>Jellylorum</button>
>       </nav>
>       <div>
>         <ul>
>           {catList.map((cat) => (
>             <li
>               key={cat.id}
>               ref={(node) => {
>                 const map = getMap();
>                 if (node) {
>                   map.set(cat.id, node);
>                 } else {
>                   map.delete(cat.id);
>                 }
>               }}
>             >
>               <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
>             </li>
>           ))}
>         </ul>
>       </div>
>     </>
>   );
> }
>
> const catList = [];
> for (let i = 0; i < 10; i++) {
>   catList.push({
>     id: i,
>     imageUrl: "https://placekitten.com/250/200?image=" + i,
>   });
> }
> ```
>
> 이 예시에서 `itemsRef`는 하나의 DOM노드를 붙들고 있지 않는다. 대신에 아이템의 ID에서 DOM 노드로의 Map을 저장한다. 모든 리스트 내 아이템에 대한 `ref` 콜백은 이 Map을 업데이트하는 것에만 신경쓴다.
>
> ```jsx
> <li
>   key={cat.id}
>   ref={node => {
>     const map = getMap();
>     if (node) {
>       // Add to the Map
>       map.set(cat.id, node);
>     } else {
>       // Remove from the Map
>       map.delete(cat.id);
>     }
>   }}
> >
> ```
>
> 이로써 후에 Map으로부터 개별 DOM 노드를 읽을 수 있게 된다.

### 다른 컴포넌트의 DOM 노드에 접근하기

ref를 `<input />` 같은 브라우저 엘리먼트를 반환하는 빌트인 컴포넌트에 놓으면, 리액트는 그 ref의 `current` 프로퍼티를 해당하는 DOM 노드로 설정한다.

그러나 만약 ref를 **직접 만든** 컴포넌트에 놓으면, 디폴트로 `null`을 얻게 될 것이다. 아래 예시에서 버튼을 클릭하는 일은 인풋에 포커스 이벤트를 일으키지 **않는다**.

```jsx
import { useRef } from "react";

function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이런 일이 일어나는 이유는 기본적으로 리액트가 컴포넌트로 하여금 다른 컴포넌트의 DOM 노드에 접근하지 못하게 하기 때문이다. 그 자신의 직접적인 `children`일지라도 말이다. 이는 의도된 것인데, ref는 하나의 비상구로서 오직 한정적으로만 사용되어야 한다. 임의로 **다른** 컴포넌트의 DOM 노드를 조작하는 것은 많은 오류를 낳을 수 있다.

대신에 자신의 DOM 노드를 바깥에 노출시키기를 **원하는** 컴포넌트들은 해당 동작에 **동의해야**(opt in) 한다. 컴포넌트는 자신의 ref를 자신의 `children` 중 하나에 "전달할"(forward) 것임을 특정할 수 있다. 아래는 어떻게 `<MyInput>`이 `forwardRef` API를 이용하여 이를 수행하는지 보여준다:

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

이것의 작동 방식은 아래와 같다:

1. `<MyInput ref={inputRef}>`는 리액트에게, 해당하는 DOM 노드를 `inputRef.current`에 놓으라고 말한다. 그러나 여기에 동의하는/참석하는 일은 `<MyInput>` 컴포넌트에게 달려있다.
2. `<MyInput>` 컴포넌트는 `forwardRef`를 이용해 선언되었다. **이는 상위 컴포넌트로부터 `inputRef`를 두 번째 ref 인자(props 뒤에 선언된다)로 받기를 동의하도록 한다.**
3. `<MyInput>` 자신은 전달받은 ref를 내부의 `<input>`에 전달한다.

이제 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

디자인 시스템에서는 버튼이나 인풋 같은 하위 레벨 컴포넌트들이 자신들의 ref를 아래 DOM 노드로 전달하는 것이 일반적인 패턴이다. 다른 한편 폼이나 리스트, 페이지 섹션 같은 상위 레벨 컴포넌트는 자신들의 DOM 노드를 노출시키지 않음으로써 DOM 구조의 우연스러운 의존성을 피한다.

> **명령형 핸들을 이용하여 API의 서브셋을 노출시키기**  
> 위 예시에서 `<MyInput>`은 오리지널 DOM 인풋 엘리먼트를 노출시켜 부모 컴포넌트가 그에 대한 `focus()`를 호출할 수 있도록 하기도 하지만, 인풋의 CSS를 변경하는 등과 다른 일들을 수행할 수 있도록 할 수도 있다. 일반적인 일은 아니지만 이렇게 노출되는 기능성을 제한하고자 할 수도 있는데, 이때는 `useImperativeHandle` 훅을 이용할 수 있다.
>
> ```jsx
> import { forwardRef, useRef, useImperativeHandle } from "react";
>
> const MyInput = forwardRef((props, ref) => {
>   const realInputRef = useRef(null);
>   useImperativeHandle(ref, () => ({
>     // Only expose focus and nothing else
>     focus() {
>       realInputRef.current.focus();
>     },
>   }));
>   return <input {...props} ref={realInputRef} />;
> });
>
> export default function Form() {
>   const inputRef = useRef(null);
>
>   function handleClick() {
>     inputRef.current.focus();
>   }
>
>   return (
>     <>
>       <MyInput ref={inputRef} />
>       <button onClick={handleClick}>Focus the input</button>
>     </>
>   );
> }
> ```
>
> 여기서 `<MyInput>` 내의 `realInputRef`는 실제 인풋 DOM 노드를 갖는다. 하지만 `useImperativeHandle`은 리액트로 하여금 ref 값이 될 고유의 특별한 객체를 부모 컴포넌트에 제공하도록 지시한다. 따라서 `<Form>` 컴포넌트 내의 `inputRef.current`는 `focus` 매서드만을 갖는다. 이 경우 ref의 "핸들/손잡이"는 DOM 노드가 아닌, `useImperativeHandle` 호출 안에서 생성한 커스텀 객체이다.

### 리액트가 ref를 붙이는 시점

리액트에서 모든 업데이트는 두 단계로 분리된다.

- **렌더링** 중에 리액트는 컴포넌트를 호출하여 무엇이 화면에 존재해야 하는지 계산한다.
- **커밋** 중에 리액트는 변경 사항을 DOM에 적용한다.

일반적으로 렌더링 중에는 ref에 접근하길 원치 않을 것이다. 이는 ref가 DOM 노드를 가지는 경우에도 마찬가지이다. 초기 렌더링 중에 DOM 노드는 아직 생성되지 않으므로 `ref.current`는 `null`이다. 또한 변경사항을 렌더링하는 중에 DOM 노드는 아직 업데이트되지 않으므로 해당 시점에 노드를 읽는 것은 너무 빠른 일이 될 것이다.

리액트는 커밋 중에 `ref.current`를 설정한다. DOM을 업데이트하기 전에 리액트는 영향을 받는 `ref.current`의 값을 `null`로 설정한다. DOM을 업데이트한 후에 리액트는 즉시 이들을 해당하는 DOM 노드로 설정한다.

> **`flushSync`로 상태 업데이트를 동기적으로 수행하기**  
> 아래 코드는 새로운 투두를 추가하고 리스트의 마지막 자식으로 화면을 스크롤한다. 그러나 어떤 이유로 인해 이 코드는 항상 방금 추가된 아이템의 바로 이전 투두로 스크롤한다.
>
> ```jsx
> import { useState, useRef } from "react";
>
> export default function TodoList() {
>   const listRef = useRef(null);
>   const [text, setText] = useState("");
>   const [todos, setTodos] = useState(initialTodos);
>
>   function handleAdd() {
>     const newTodo = { id: nextId++, text: text };
>     setText("");
>     setTodos([...todos, newTodo]);
>     listRef.current.lastChild.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>     });
>   }
>
>   return (
>     <>
>       <button onClick={handleAdd}>Add</button>
>       <input value={text} onChange={(e) => setText(e.target.value)} />
>       <ul ref={listRef}>
>         {todos.map((todo) => (
>           <li key={todo.id}>{todo.text}</li>
>         ))}
>       </ul>
>     </>
>   );
> }
>
> let nextId = 0;
> let initialTodos = [];
> for (let i = 0; i < 20; i++) {
>   initialTodos.push({
>     id: nextId++,
>     text: "Todo #" + (i + 1),
>   });
> }
> ```
>
> 이슈는 아래 두 줄의 코드에서 발생한다.
>
> ```javascript
> setTodos([...todos, newTodo]);
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 리액트에서 상태의 업데이트는 큐(대기 행렬)를 형성한다. 이는 일반적으로는 문제가 되지 않지만, 위 상황에서는 `setTodos`가 즉시 DOM을 업데이트하지 않아 문제가 생긴다. 즉 리스트를 마지막 엘리먼트로 스크롤하는 시점에 새로운 투두가 아직 추가되지 않은 것이다. 이것이 스크롤이 항상 한 아이템만큼 "뒤쳐지는" 이유이다.  
> 이를 해결하기 위해 리액트가 DOM을 동기적으로 업데이트하도록("씻어내도록, flush") 강제할 수 있다. 우선 `react-dom`에서 `flushSync`를 import 하고, **상태 업데이트를 `flushSync` 호출로 감싸면** 된다.
>
> ```javascript
> flushSync(() => {
>   setTodos([...todos, newTodo]);
> });
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 이는 리액트가 `flushSync`로 감싸진 코드가 실행된 직후에 동기적으로 DOM을 업데이트하도록 지시한다. 결과적으로 마지막 투두는 스크롤을 시도하는 시점에 이미 DOM에 존재하게 된다.

## 이팩트로 동기화하기

어떤 컴포넌트는 외부 시스템에 동기화되어야 한다. 가령 컴포넌트가 화면에 나타났을 때, 리액트 상태에 기반하여 비리액트(non-React) 컴포넌트를 제어하거나 서버 연결을 설정하거나 분석 로그를 보내는 등의 일을 수행해야 할 수 있다. **이팩트**는 렌더링 이후에 특정 코드를 실행하게 하여 컴포넌트를 리액트 외부의 시스템에 동기화시킬 수 있게 한다.

### 이팩트란 무엇이고 이벤트와는 어떻게 다른가?

이팩트에 대해 알아보기 전에 리액트 컴포넌트 내부 로직의 두 가지 유형에 대해 이해할 필요가 있다:

- **렌더링 코드**(UI의 묘사)는 컴포넌트의 최상위에 존재한다. 여기서 props와 상태를 취하고, 이들을 변형시키며, 화면에서 보고자 하는 JSX를 반환한다. 렌더링 코드는 반드시 순수해야 한다. 마치 수학 공식처럼, 렌더링 코드는 결과물을 **계산하는** 것 외의 어떤 일도 수행해서는 안 된다.
- **이벤트 핸들러**(상호작용의 추가)는 컴포넌트 내의 네스팅된 함수로, 어떤 것을 계산하기보다는 **수행한다**. 이벤트 핸들러는 인풋 필드를 업데이트하거나, 상품을 구매하기 위한 HTTP `POST` 리퀘스트를 제출하거나, 유저를 다른 화면으로 네비게이션시키는 등의 일을 수행할 수 있다. 이벤트 핸들러는 특정 유저 액션(버튼 클릭이나 타이핑 같은 것들)에 의한 "사이드 이팩트"(프로그램의 상태를 변경)를 포함한다.

그러나 이걸로는 충분하지 않은 경우가 있을 수 있다. 가령 화면에 보일 때마다 채팅 서버에 연결되어야 하는 `<ChatRoom />` 컴포넌트를 생각해보자. 서버에 연결하는 일은 순수한 계산이 아니므로(사이드 이팩트이므로), 렌더링 중에 일어날 수는 없다. 그렇다고 클릭과 같은 특정한 이벤트로 인해 `<ChatRoom />`이 보여지는 것도 아니다.

**이팩트는 특정 이벤트보다는 렌더링 자체로 인해 발생하는 사이드 이팩트를 명시하도록 한다.** 메시지를 보내는 일은 유저가 특정 버튼을 누르는 행위로부터 직접적으로 촉발되는 것이므로 하나의 이벤트이다. 이와 달리 서버 연결을 설정하는 일은 이팩트이다. 왜냐하면 이는 어떤 상호작용에 의해 컴포넌트가 나타났는가 하는 것과는 상관 없이 일어나는 일이기 때문이다. 이팩트는 화면이 업데이트된 이후, 커밋의 가장 마지막 단계에 실행되는데, 이는 외부 시스템에 리액트 컴포넌트를 동기화하기에 좋은 시점이기 때문이다.

> 여기서 대문자 "Effect"는 리액트 특유의 정의, 즉 렌더링에 의한 사이드 이팩트를 나타낸다. 더 넓은 프로그래밍적 개념을 나타낼 때에는 "side effect"라 하겠다.

### 이팩트가 필요하지 않을 수 있다

**컴포넌트에 이팩트를 추가하는 데 급급해서는 안 된다.** 이팩트는 일반적으로 리액트 코드로부터 "벗어나" 어떤 "외부의" 시스템과 동기화하는 데 이용된다. 만약 어떤 이팩트가 어떤 상태에 기반하여 다른 상태를 조정하는 일만을 수행한다면, 이 경우 이팩트는 필요하지 않을 수 있다.

### 이팩트를 작성하는 방법

이팩트를 작성하기 위해서는 아래 세 가지 스텝을 따라야 한다:

1. **이팩트 선언하기** : 기본적으로 이팩트는 매 렌더링 이후에 실행된다.
2. **이팩트 의존성 명시하기** : 대부분의 이팩트는 매 렌더링 이후가 아니라, **필요한 경우에** 재실행되어야 한다.
3. **필요에 따라 클린업 추가하기** : 어떤 이팩트에서는 그것이 수행하던 일을 중지, 취소 또는 클린업하는 방식을 명시해야 할 수 있다.

#### 스텝 1. 이팩트 선언하기

이팩트를 선언하기 위해서는 리액트로부터 `useEffect` 훅을 import 해야 한다.

```javascript
import { useEffect } from "react";
```

그런 후 컴포넌트의 최상위에서 훅을 호출하고, 이팩트 안에 코드를 집어넣는다.

```tsx
function MyComponent() {
  useEffect(() => {
    // 이곳의 코드는 *매* 렌더링마다 실행될 것이다.
  });
  return <div />;
}
```

컴포넌트가 렌더링될 때마다 리액트는 화면을 업데이트한 **이후에** `useEffect` 안의 코드를 실행한다. 달리 표현하면 **`useEffect`는 렌더링 결과물이 화면에 반영되기까지 일부 코드의 실행을 "지연시킨다".**

어떻게 이팩트를 사용하여 외부 시스템과 동기화할 수 있는지 살펴보자. `<VideoPlayer>`라는 리액트 컴포넌트를 생각해보면, `isPlaying`이라는 prop을 전달하여 비디오의 재생 여부를 제어할 수 있으면 좋을 것이다:

```tsx
<VideoPlayer isPlaying={isPlaying} />
```

커스텀 `<VideoPlayer />` 컴포넌트는 빌트인 브라우저 태그인 `<video>`를 렌더링한다:

```tsx
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

그러나 브라우저의 `<video>` 태그는 `isPlaying` prop을 갖지 않는다. 이를 제어하는 유일한 방법은 수동으로 DOM 엘리먼트의 `play()`, `pause()` 매서드를 실행하는 것이다. 이때 **비디오가 현재 재생 중*이어야만 하는지* 여부를 말해주는 `isPlaying` prop 값을, `play()` 또는 `pause()` 매서드의 호출과 동기화시켜야 한다.**

우선은 `<video>` DOM 노드에 대한 ref를 얻어야 한다. 렌더링 중에 `play()`나 `pause()`를 호출해볼 수 있겠으나, 이는 올바른 방법이 아니다:

```tsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play(); // 렌더링 중에 이를 호출하는 일은 허용되지 않는다.
  } else {
    ref.current.pause(); // 이 부분도 에러를 일으킨다.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

위 코드가 올바르지 않은 이유는 렌더링 도중에 DOM 노드를 이용하여 무언가 하려 하기 때문이다. 리액트에서 렌더링은 JSX의 순수한 계산이어야 하며, DOM의 변형과 같은 사이드 이팩트를 포함해서는 안 된다.

더 나아가 `<VideoPlayer />`가 처음 호출되는 시점에 해당 DOM은 아직 존재하지 않는다. `play()`나 `pause()`를 호출할 DOM 노드가 아직 존재하지 않는 것인데, 이는 JSX가 반환되기까지 리액트가 어떤 DOM을 생성해야 할지 알지 못하기 때문이다.

여기서 해결방안은 **사이드 이팩트를 `useEffect`로 감싸서 렌더링 계산 바깥으로 이동시키는 것**이다.

```tsx
import { useEffect, useRef } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

DOM 업데이트를 이팩트로 감싸서 리액트가 화면을 먼저 업데이트하도록(커밋하도록) 하고, 그 이후에 이팩트가 실행되도록 할 수 있다.

`<VideoPlayer />`가 렌더링될 때(초기 렌더링이든 리렌더링이든) 몇 가지 일이 일어난다. 첫째로 리액트가 화면을 업데이트하여 `<video>` 태그가 적절한 props와 함께 DOM에 존재하도록 한다. 그 다음 리액트는 이팩트를 실행한다. 마지막으로 이팩트가 `isPlaying`의 값에 따라 `play()`나 `pause()`를 호출한다.

#### 스텝 2. 이팩트 의존성 명시하기

기본적으로 이팩트는 **매** 렌더링 이후에 실행된다. 하지만 많은 경우 이는 **개발 의도에 부합하지 않는다**.

`useEffect` 호출에 두 번째 인자로 **의존성**의 배열을 명시함으로써 **이팩트를 불필요하게 재실행하는 것을 생략**하도록 할 수 있다. 우선 빈 `[]` 배열을 추가해보자:

```typescript
useEffect(() => {
  // ...
}, []);
```

이때 `React Hook useEffect has a missing dependency: 'isPlaying'`이라는 에러를 볼 수 있다:

```tsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log("Calling video.play()");
      ref.current.play();
    } else {
      console.log("Calling video.pause()");
      ref.current.pause();
    }
  }, []); // 여기서 에러가 발생한다.

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState("");
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

여기서 문제는, 이팩트 안의 코드가 어떤 일을 수행할지 결정하는 데 있어서 `isPlaying` prop에 **의존하고** 있지만, 이러한 의존성이 명시적으로 선언되지 않았다는 데 있다. 이를 해결하려면 `isPlaying`을 의존성 배열에 추가해야 한다:

```typescript
useEffect(() => {
  if (isPlaying) {
    // 여기에서 사용되었으므로…
    // ...
  } else {
    // ...
  }
}, [isPlaying]); // …여기에 반드시 선언되어야 한다!
```

이제 모든 의존성이 선언되었으므로 에러는 발생하지 않는다. 의존성 배열로 `[isPlaying]`을 명시하는 일은 리액트에게 `isPlaying`이 이전 렌더링 시의 값과 동일하다면 해당 이팩트의 재실행을 건너뛰라고 얘기하는 것과 같다.

의존성 배열은 다수의 의존성을 포함할 수 있다. 리액트는 명시된 의존성이 **모두** 이전 렌더링 시점의 값과 정확히 일치할 때에만 이팩트의 재실행을 스킵한다. 리액트는 `Object.is` 비교를 이용해 의존성 값들을 비교한다.

이때 **의존성을 "선택"할 수는 없다는 점에 유의하자.** 만약 명시한 의존성이 이팩트 내의 코드에 기반하여 리액트가 예상한 의존성과 일치하지 않는다면 린트 에러가 발생할 것이다. 이는 코드의 많은 버그를 잡아내는 데 유용하다.

> **주의**  
> 의존성 배열이 없는 것과 빈 `[]` 의존성 배열을 갖는 것은 다르게 동작한다:
>
> ```typescript
> useEffect(() => {
>   // 모든 렌더링마다 실행된다.
> });
>
> useEffect(() => {
>   // 마운트 시에만(컴포넌트가 나타날 때) 실행된다.
> }, []);
>
> useEffect(() => {
>   // 마운트 시 *뿐만 아니라* a 또는 b가 이전 렌더링 이후 변경되었을 때 실행된다.
> }, [a, b]);
> ```

> **왜 ref는 의존성 배열에서 생략되는가?**  
> 위 이팩트는 `ref`와 `isPlaying`을 **모두** 사용하지만, `isPlaying`만이 의존성으로 선언된다. 이는 ref 객체가 **안정적 아이덴티티**를 갖기 때문인데, 리액트는 매 렌더링마다 동일 `useRef` 호출로부터 동일한 객체를 항상 얻을 것임을 보증한다. 절대 변화하지 않으므로 그 자체로서는 이팩트의 재실행을 유도하지 않는 것이다. 따라서 `ref`를 포함시키는 여부는 아무런 문제가 되지 않는다.  
> 항시 안정적인 의존성을 생략하는 일은 린트가 해당 객체가 안정적임을 **볼** 수 있을 때에만 가능하다. 가령 어떤 ref가 부모 컴포넌트로부터 전달된다면, 이것은 의존성 배열에 명시되어야 한다. 이는 나쁘기만 한 것은 아닌데, 왜냐하면 부모 컴포넌트가 항상 동일한 ref를 보내는지, 혹은 여러 ref 중 하나를 조건적으로 보내는지 알 수 없기 때문이다.

#### 스텝 3. 필요에 따라 클린업 추가하기

다른 예시로, 화면에 나타날 때 채팅 서버에 연결되어야 하는 `<ChatRoom />` 컴포넌트를 생각해보자. `connect()`와 `disconnect()` 매서드를 갖는 객체를 반환하는 `createConnection()` API가 주어진다면, 어떻게 컴포넌트가 유저에게 보여지는 동안 연결을 유지할 수 있을까?

우선 이팩트 로직을 작성하는 데에서 시작해보자:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});
```

매 렌더링 시마다 채팅 서버에 연결하는 것은 느릴 수 있으니 의존성 배열을 추가하는 것이 좋겠다:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

**이팩트 내의 코드가 어떤 props나 상태도 이용하지 않으므로 이때의 의존성 배열은 `[]`이다. 이것은 리액트에게 해당 코드를 컴포넌트가 "마운트"할 때에만, 즉 화면에 처음으로 나타날 때에만 실행하라고 말하는 것과 같다.**

그럼 이 코드를 실행해보자:

```tsx
import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

이 이팩트는 마운트 시에만 실행되므로 콘솔에 `✅ Connecting…`이 한 번만 출력될 것으로 예상할 수 있다. **하지만 콘솔을 확인해보면 `✅ Connecting…`이 두 번 출력된다.**

`<ChatRoom />` 컴포넌트가 여러 다른 화면을 가진 커다란 앱의 일부분이라 생각해보자. 유저가 `<ChatRoom />` 페이지에 방문하면 컴포넌트가 마운트하고 `connection.connect()`가 호출된다. 이후 유저가 다른 화면으로 이동하면 `<ChatRoom />`은 언마운트한다. 그리고 유저가 뒤로가기 버튼을 누르면 `<ChatRoom />`이 다시 마운트할텐데, 이는 두 번째 연결을 설정하겠지만, 이전의 첫 번째 연결은 끊어지지 않은 상태이다. 유저가 앱의 이곳저곳을 네비게이션할수록 서버 연결은 계속해서 중첩될 것이다.

이러한 버그를 찾아내는 데 도움을 주기 위해 개발 모드에서 리액트는 모든 컴포넌트를 초기 마운트 바로 직후에 한 번 더 리마운트한다.

위에서 `✅ Connecting...` 로그가 두 번 나타나는 것은 실제 이슈, 즉 기존 코드가 컴포넌트 언마운트 시에 연결을 끊지 않는다는 것을 확인시켜준다.

이를 해결하기 위해 이팩트로부터 **클린업 함수**를 반환해야 한다:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

리액트는 이팩트가 재실행될 때마다, 그리고 마지막으로는 컴포넌트가 언마운트할 때(제거될 때), 클린업 함수를 호출한다.

이제 개발 모드에서 세 개의 콘솔 로그를 보게 될 것이다:

1. `✅ Connecting…`
2. `❌ Disconnected!`
3. `✅ Connecting…`

**개발 모드에서 이는 정상적인 동작이다.** 컴포넌트를 리마운트함으로써 리액트는 해당 네비게이션을 왔다갔다 수행하는 일이 코드를 망가뜨리지 않는지 검증한다. 연결을 끊었다가 재연결하는 것은 분명 일어나야만 하는 일이라는 것이다. 클린업을 잘 구현한다면 이팩트를 한 번만 실행하는 것과 실행했다가 클린업 했다가 다시 실행하는 것 사이에서 유저가 볼 수 있는 차이점은 없을 것이다.

**프로덕션 모드에서는 `✅ Connecting...`이 한 번만 출력될 것이다.** 컴포넌트의 리마운트는 개발 모드에서만 일어나 클린업의 필요성을 확인하는 데 도움을 준다.
