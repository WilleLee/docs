# 비상구

어떤 컴포넌트는 리액트 바깥의 시스템을 제어하거나 거기에 동기화해야 할 수 있다. 가령 브라우저 API를 이용해 인풋을 포커스한다든지, 리액트 없이 구현된 비디오 플레이어를 플레이 또는 중지한다든지, 원격 서버로부터의 메세지를 연결하는 등의 동작이 필요할 수 있다. 이 챕터에서는 리액트 "바깥으로 나가" 외부 시스템과 연결하도록 할 비상구에 대해 배울 것인데, 어플리케이션의 대부분의 로직 및 데이터 흐름은 이러한 특성에 기대지 말아야 한다.

## ref를 이용하여 값 참조하기

컴포넌트가 어떤 정보를 "기억"하기는 하지만 해당 정보가 새로운 렌더링을 촉발하지는 않기를 바라는 경우 **ref**를 사용할 수 있다.

### 컴포넌트에 ref 추가하기

리액트에서 `useRef` 훅을 import 하여 컴포넌트에 ref를 추가할 수 있다.

```jsx
import { useRef } from "react";
```

컴포넌트 안에서 `useRef` 훅을 호출하고 유일한 인자로 원하는 초기값을 전달한다. 가령 아래에서 ref의 값은 `0`이 된다:

```jsx
const ref = useRef(0);
```

`useRef`는 아래와 같은 객체를 반환한다:

```javascript
{
  current: 0, // useRef에 전달한 값
}
```

`ref.current` 프로퍼티를 통해 위 `ref`의 현재 값에 접근할 수 있다. 이 값은 의도적으로 뮤테이션 가능한데, 즉 해당 값을 읽을 수도, 쓸 수도 있다. 이는 리액트가 추적하지 않는 컴포넌트의 비밀 주머니와 같다.

아래 예시에서는 버튼을 클릭할 때마다 `ref.current`의 값이 증가할 것이다:

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

상태와 같이 ref는 어떤 형태의 값이든, 가령 문자열이든 객체이든 심지어는 함수이든 간에 가리킬 수 있다. 상태와 다른 점은 ref가 읽거나 변형할 수 있는 `current` 프로퍼티를 갖는 일반적인 자바스크립트 객체라는 점이다.

**위 `ref.current` 값이 상승할 때 컴포넌트가 리렌더링되지 않는다는 점**에 주목하자. 상태와 같이 ref는 리렌더링 사이에 유지된다. 그러나 상태의 세팅은 컴포넌트를 리렌더링하는 한편 ref의 변경은 그렇지 않다.

### 예시 : 스톱워치 만들기

ref와 상태를 하나의 컴포넌트에서 함께 사용할 수 있다. 예를 들어 버튼을 클릭하여 시작하거나 멈출 수 있는 스톱워치를 만든다고 해보자. 유저가 "Start" 버튼을 누른 후로 얼마나 지났는지 보여주기 위해서는 언제 시작 버튼이 눌렸는지, 그리고 현재 시간은 무엇인지를 추적할 필요가 있다. **이 정보는 렌더링에 이용되므로 상태에 보관해볼 수 있다.**

```jsx
const [startTime, setStartTime] = useState(null);
const [now, setNow] = useState(null);
```

유저가 시작 버튼을 누르면 10 밀리세컨드마다 시간을 업데이트하기 위해 `setInterval`을 사용한다.

```jsx
import { useState } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    // Start counting.
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      // Update the current time every 10ms.
      setNow(Date.now());
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
    </>
  );
}
```

"Stop" 버튼이 눌릴 때 현재 존재하는 인터벌을 멈춰 `now` 상태 변수의 업데이트를 멈춰야 한다. 이는 `clearInterval`을 호출하여 수행할 수 있는데, 이를 위해 유저가 시작 버튼을 누를 때의 `setInterval` 호출로부터 반환되는 인터벌 ID가 필요하다. 그러므로 인터벌 ID를 어딘가에 보관해야 한다. **이때 인터벌 ID는 렌더링에 사용되지 않으므로 ref에 보관해볼 수 있다.**

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

정보의 한 부분이 렌더링에 이용된다면 상태에 보관하면 되고, 만약 이벤트 핸들러에서만 필요하고 해당 정보의 변경이 리렌더링을 필요로 하지 않는다면 ref를 이용하는 것이 더 효율적일 것이다.

### ref와 상태의 차이점

대부분의 경우에서는 상태를 사용하게 되며, ref는 자주 필요하지는 않은 일종의 "비상구"이다. 아래는 상태와 ref를 비교해본 것이다:

| ref                                                                              | 상태                                                                                                  |
| -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `useRef(initialValue)`는 `{ current: initialValue }`를 반환한다.                 | `useState(initialValue)`는 상태 변수의 현재 값과 상태 세터 함수를 반환한다.<br/>(`[value, setValue]`) |
| 변경 시에도 리렌더링을 촉발하지 않는다.                                          | 변경 시 리렌더링을 촉발한다.                                                                          |
| mutable : `current`의 값을 렌더링 프로세스 바깥에서 변경 및 업데이트 할 수 있다. | immutable : 리렌더링 큐를 쌓기 위해 상태 세터 함수를 이용하여 상태 변수를 변경해야만 한다.            |
| 렌더링 시점에 `current` 값을 읽거나 써서는 안 된다.                              | 언제든지 상태를 읽을 수 있다.<br/>다만 각 렌더링 시점은 변하지 않는 고유한 상태 스냅샷을 갖는다.      |

아래 카운터 버튼 예시는 상태와 함께 구현된다.

```jsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>You clicked {count} times</button>;
}
```

`count`의 값이 화면에 보여지기 때문에 이 경우 상태 값을 이용하는 것이 합리적이다. 카운터의 값이 `setCount()`로 변경되면 리액트는 컴포넌트를 리렌더링하고 스크린은 새로운 `count`를 반영하기 위해 업데이트될 것이다.

만약 이를 ref를 이용해 구현하려 했다면 리액트는 결코 컴포넌트를 리렌더링하지 않을 것이므로 카운터가 변화하는 것을 보지 못할 것이다. 이것이 `ref.current`를 렌더링 시에 읽는 일이 신뢰도 떨어지는 코드로 귀결되는 이유이다.

> **내부적으로 `useRef`는 어떻게 동작하는가?**  
> `useState`와 `useRef` 모두 리액트에 의해 제공되기는 하지만, 원칙적으로 `useRef`는 `useState`의 **위에서** 구현될 수 있다. 가령 리액트 내부에서는 `useRef`가 아래와 같이 구현되어 있다고 상상해볼 수 있다:
>
> ```jsx
> // Inside of React
> function useRef(initialValue) {
>   const [ref, unused] = useState({ current: initialValue });
>   return ref;
> }
> ```
>
> 초기 렌더링 시에 `useRef`는 `{ current: initialValue }`를 반환한다. 이 객체는 리액트에 저장되므로 다음 렌더링 시에 동일한 객체가 반환될 것이다. 이 예시에서 상태 세터가 이용되지 않는다는 점에 유의하자. 이는 불필요한데, 왜냐하면 `useRef`가 항상 동일한 객체를 반환할 필요가 있기 때문이다.

### 언제 ref를 이용해야 할까?

일반적으로 ref는 컴포넌트가 리액트 "바깥으로 나가" 외부 API들, 가령 컴포넌트의 외형에 영향을 주지 않는 브라우저 API와 소통해야 할 때 사용된다. 아래는 이런 몇 안 되는 상황들의 예시이다:

- 타임아웃 ID의 저장
- DOM 엘리먼트의 저장 및 조작
- JSX 계산에는 필요하지 않은 다른 객체들의 저장

만약 컴포넌트가 어떤 값을 저장하는데, 이 값이 렌더링 로직에는 영향을 주지 않는다면 ref를 선택하는 것이 바람직하다.

### 최적의 ref 사용법

아래 원칙들을 따름으로써 보다 예측 가능한 컴포넌트를 만들 수 있다:

- ref를 일종의 비상구처럼 다루기  
  ref는 외부 시스템이나 브라우저 API를 이용할 때 유용하다. 만약 앱의 로직 및 데이터 흐름의 많은 부분이 ref에 의존한다면, 접근 방식에 대해 다시 생각해볼 필요가 있을 것이다.
- 렌더링 중에 `ref.current`를 읽거나 쓰지 않기  
  렌더링 중에 어떤 정보가 필요하다면 ref가 아닌 상태를 이용하자. 리액트는 언제 `ref.current`가 변화하는지 알지 못하므로, 렌더링 중에 `ref.current`를 읽어들이는 일조차도 컴포넌트의 동작을 예측하기 어렵게 할 것이다.

리액트 상태의 한계는 ref에 적용되지 않는다. 가령 상태는 매 렌더링 시에 스냅샷처럼 행동하고 동기적으로 업데이트하지는 않는 반면, ref의 현재 값을 뮤테이션하면 그 값은 그 즉시 변경된다.

```javascript
ref.current = 5;
console.log(ref.current); // 5
```

이는 **ref 자신이 일반 자바스크립트 객체**이며 그와 같이 행동하기 때문이다.

또한 ref를 이용하는 중에는 뮤테이션을 피해야 한다는 걱정을 할 필요가 없다. 뮤테이션 되는 객체가 렌더링에 이용되지 않는 한, 리액트는 ref나 그것의 컨텐츠에 어떤 일이 일어나든 신경쓰지 않는다.

### ref와 DOM

ref로는 어떤 형태의 값이든 가리킬 수 있지만, ref를 이용하는 가장 일반적인 유즈케이스는 DOM 엘리먼트에 접근하는 일이다. 가령 어떤 인풋에 프로그래밍적으로 포커스하기를 원한다면 이는 매우 유용할 것이다. `<div ref={myRef}>`와 같이 ref를 JSX의 `ref` 속성에 전달하면, 리액트는 해당하는 DOM 엘리먼트를 `myRef.current`에 저장할 것이다. 그 엘리먼트가 DOM에서 삭제되는 순간 리액트는 `myRef.current`를 `null`로 업데이트할 것이다.

## ref를 이용해 DOM 조작하기

리액트가 자동으로 DOM을 업데이트하여 렌더링 아웃풋과 일치시키기 때문에 컴포넌트는 대부분의 경우 DOM을 직접 조작할 필요가 없다. 그러나 어떤 경우에는 리액트가 관리하는 DOM 엘리먼트에 대한 접근 권한이 필요할 수 있는데, 가령 특정 노드를 포커스하거나, 거기로 스크롤하거나, 노드의 사이즈 또는 위치를 측정하거나 하는 경우 그렇다. 리액트에 그런 일을 수행할 방법이 내장되어 있지 않기 때문에 이 경우 DOM 노드에 대한 **ref**가 필요하다.

### 노드에 대한 ref 얻기

리액트에 의해 관리되는 DOM 노드에 접근하기 위해서는 우선 `useRef` 훅을 import 해야 한다. 그런 후 이를 이용해 컴포넌트 안에서 ref를 선언한다. 끝으로는 ref를 DOM 노드를 취하고자 하는 JSX 태그에 `ref` 속성으로 전달한다.

```jsx
<div ref={myRef} />
```

`useRef` 훅은 `current`라고 불리는 하나의 프로퍼티를 갖는 객체를 반환한다. 초기에 `myRef.current`는 `null`이다. 리액트가 이 `<div>`에 대한 DOM 노드를 생성하면, 리액트는 이 노드에 대한 참조를 `myRef.current`에 저장한다. 그러면 이벤트 핸들러를 이용해 해당 DOM 노드에 접근할 수 있게 되며, 그에 대해 정의된 빌트인 브라우저 API들을 사용할 수 있게 된다.

```javascript
// 어떤 브라우저 API든 사용할 수 있다. 가령:
myRef.current.scrollIntoView();
```

### 예시 : 텍스트 인풋 포커스하기

아래 예시에서 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이를 구현하기 위해:

1. `useRef` 훅으로 `inputRef`를 선언한다.
2. 이를 `<input ref={inputRef}>` 형태로 전달한다. 이로써 리액트는 **이 `<input>`의 DOM 노드를 `inputRef.current`에 집어넣는다.**
3. `handleClick` 함수에서 `inputRef.current`를 통해 인풋 DOM 노드를 읽고, `inputRef.current.focus()`와 같이 해당 DOM 노드의 `focus()` 매서드를 호출한다.
4. `onClick`을 이용해 `handleClick` 이벤트 핸들러를 `<button>`에 전달한다.

DOM을 조작하는 것이 ref의 가장 일반적인 유즈케이스이긴 하지만, `useRef` 훅은 타이머 ID와 같은, 리액트 바깥의 많은 것들을 보관하는 데 사용될 수 있다. 상태와 유사하게 ref는 렌더링 중에 유지된다. ref는 변경 시 리렌더링을 촉발하지 않는 상태 변수라고 할 수 있겠다.

### 예시 : 특정 엘리먼트로 스크롤하기

하나의 컴포넌트 안에 다수의 ref를 포함시킬 수 있다. 아래 예시에는 세 가지 이미지의 캐러셀이 있다. 각각의 버튼은 해당하는 DOM 노드의 `scrollIntoView()` 브라우저 매서드를 호출하여 이미지를 가운데에 위치시킨다:

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>Tom</button>
        <button onClick={handleScrollToSecondCat}>Maru</button>
        <button onClick={handleScrollToThirdCat}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placekitten.com/g/200/200"
              alt="Tom"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/300/200"
              alt="Maru"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/250/200"
              alt="Jellylorum"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}
```

> `ref` 콜백을 이용하여 ref들의 리스트를 관리하는 방법  
> 위 예시에서는 ref의 수가 사전에 정의되어 있다. 하지만 어떤 경우에는 특정 리스트의 각 아이템에 대한 ref의 선언이 필요하기는 하지만 아이템의 수는 알지 못할 수도 있다. 이때 아래와 같은 로직은 **작동하지 않을 것**이다.
>
> ```jsx
> <ul>
>   {items.map((item) => {
>     // Doesn't work!
>     const ref = useRef(null);
>     return <li ref={ref} />;
>   })}
> </ul>
> ```
>
> 이는 **훅은 반드시 컴포넌트의 최상단에서만 호출되어야** 하기 때문이다. 반복문이나 조건문, `map()` 호출 내부에서는 `useRef`를 호출할 수 없다.  
> 이와 관련해 적용해볼 수 있는 한 가지 방법은 부모 엘리먼트에 대한 하나의 ref를 가져와 `querySelectorAll`과 같은 DOM 조작 매서드를 사용하여 개별적인 자식 노드를 "찾아내는" 것이다. 하지만 이는 다루기 힘들고, DOM 구조가 변한다면 더 이상 작동하지 않을 수 있다.  
> 또 다른 해결 방법은 **`ref` 속성에 함수를 전달**하는 것이다. 이러한 일을 **`ref` 콜백**이라 한다. 리액트는 ref를 설정할 때에는 `ref` 콜백을 DOM 노드와 함께 호출하고, ref를 비울 때에는 `ref` 콜백을 `null`과 함께 호출한다. 이를 통해 어떤 배열이나 Map을 유지할 수 있으며, 어떤 ref에 대해 그것의 인덱스 값이나 특정한 ID를 통해 접근할 수 있게 된다.  
> 아래 예시는 이러한 접근법을 긴 리스트의 임의의 노드로 스콜하는 데 어떻게 이용할 수 있는지 보여준다:
>
> ```jsx
> import { useRef } from "react";
>
> export default function CatFriends() {
>   const itemsRef = useRef(null);
>
>   function scrollToId(itemId) {
>     const map = getMap();
>     const node = map.get(itemId);
>     node.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>       inline: "center",
>     });
>   }
>
>   function getMap() {
>     if (!itemsRef.current) {
>       // Initialize the Map on first usage.
>       itemsRef.current = new Map();
>     }
>     return itemsRef.current;
>   }
>
>   return (
>     <>
>       <nav>
>         <button onClick={() => scrollToId(0)}>Tom</button>
>         <button onClick={() => scrollToId(5)}>Maru</button>
>         <button onClick={() => scrollToId(9)}>Jellylorum</button>
>       </nav>
>       <div>
>         <ul>
>           {catList.map((cat) => (
>             <li
>               key={cat.id}
>               ref={(node) => {
>                 const map = getMap();
>                 if (node) {
>                   map.set(cat.id, node);
>                 } else {
>                   map.delete(cat.id);
>                 }
>               }}
>             >
>               <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
>             </li>
>           ))}
>         </ul>
>       </div>
>     </>
>   );
> }
>
> const catList = [];
> for (let i = 0; i < 10; i++) {
>   catList.push({
>     id: i,
>     imageUrl: "https://placekitten.com/250/200?image=" + i,
>   });
> }
> ```
>
> 이 예시에서 `itemsRef`는 하나의 DOM노드를 붙들고 있지 않는다. 대신에 아이템의 ID에서 DOM 노드로의 Map을 저장한다. 모든 리스트 내 아이템에 대한 `ref` 콜백은 이 Map을 업데이트하는 것에만 신경쓴다.
>
> ```jsx
> <li
>   key={cat.id}
>   ref={node => {
>     const map = getMap();
>     if (node) {
>       // Add to the Map
>       map.set(cat.id, node);
>     } else {
>       // Remove from the Map
>       map.delete(cat.id);
>     }
>   }}
> >
> ```
>
> 이로써 후에 Map으로부터 개별 DOM 노드를 읽을 수 있게 된다.

### 다른 컴포넌트의 DOM 노드에 접근하기

ref를 `<input />` 같은 브라우저 엘리먼트를 반환하는 빌트인 컴포넌트에 놓으면, 리액트는 그 ref의 `current` 프로퍼티를 해당하는 DOM 노드로 설정한다.

그러나 만약 ref를 **직접 만든** 컴포넌트에 놓으면, 디폴트로 `null`을 얻게 될 것이다. 아래 예시에서 버튼을 클릭하는 일은 인풋에 포커스 이벤트를 일으키지 **않는다**.

```jsx
import { useRef } from "react";

function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이런 일이 일어나는 이유는 기본적으로 리액트가 컴포넌트로 하여금 다른 컴포넌트의 DOM 노드에 접근하지 못하게 하기 때문이다. 그 자신의 직접적인 `children`일지라도 말이다. 이는 의도된 것인데, ref는 하나의 비상구로서 오직 한정적으로만 사용되어야 한다. 임의로 **다른** 컴포넌트의 DOM 노드를 조작하는 것은 많은 오류를 낳을 수 있다.

대신에 자신의 DOM 노드를 바깥에 노출시키기를 **원하는** 컴포넌트들은 해당 동작에 **동의해야**(opt in) 한다. 컴포넌트는 자신의 ref를 자신의 `children` 중 하나에 "전달할"(forward) 것임을 특정할 수 있다. 아래는 어떻게 `<MyInput>`이 `forwardRef` API를 이용하여 이를 수행하는지 보여준다:

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

이것의 작동 방식은 아래와 같다:

1. `<MyInput ref={inputRef}>`는 리액트에게, 해당하는 DOM 노드를 `inputRef.current`에 놓으라고 말한다. 그러나 여기에 동의하는/참석하는 일은 `<MyInput>` 컴포넌트에게 달려있다.
2. `<MyInput>` 컴포넌트는 `forwardRef`를 이용해 선언되었다. **이는 상위 컴포넌트로부터 `inputRef`를 두 번째 ref 인자(props 뒤에 선언된다)로 받기를 동의하도록 한다.**
3. `<MyInput>` 자신은 전달받은 ref를 내부의 `<input>`에 전달한다.

이제 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

디자인 시스템에서는 버튼이나 인풋 같은 하위 레벨 컴포넌트들이 자신들의 ref를 아래 DOM 노드로 전달하는 것이 일반적인 패턴이다. 다른 한편 폼이나 리스트, 페이지 섹션 같은 상위 레벨 컴포넌트는 자신들의 DOM 노드를 노출시키지 않음으로써 DOM 구조의 우연스러운 의존성을 피한다.

> **명령형 핸들을 이용하여 API의 서브셋을 노출시키기**  
> 위 예시에서 `<MyInput>`은 오리지널 DOM 인풋 엘리먼트를 노출시켜 부모 컴포넌트가 그에 대한 `focus()`를 호출할 수 있도록 하기도 하지만, 인풋의 CSS를 변경하는 등과 다른 일들을 수행할 수 있도록 할 수도 있다. 일반적인 일은 아니지만 이렇게 노출되는 기능성을 제한하고자 할 수도 있는데, 이때는 `useImperativeHandle` 훅을 이용할 수 있다.
>
> ```jsx
> import { forwardRef, useRef, useImperativeHandle } from "react";
>
> const MyInput = forwardRef((props, ref) => {
>   const realInputRef = useRef(null);
>   useImperativeHandle(ref, () => ({
>     // Only expose focus and nothing else
>     focus() {
>       realInputRef.current.focus();
>     },
>   }));
>   return <input {...props} ref={realInputRef} />;
> });
>
> export default function Form() {
>   const inputRef = useRef(null);
>
>   function handleClick() {
>     inputRef.current.focus();
>   }
>
>   return (
>     <>
>       <MyInput ref={inputRef} />
>       <button onClick={handleClick}>Focus the input</button>
>     </>
>   );
> }
> ```
>
> 여기서 `<MyInput>` 내의 `realInputRef`는 실제 인풋 DOM 노드를 갖는다. 하지만 `useImperativeHandle`은 리액트로 하여금 ref 값이 될 고유의 특별한 객체를 부모 컴포넌트에 제공하도록 지시한다. 따라서 `<Form>` 컴포넌트 내의 `inputRef.current`는 `focus` 매서드만을 갖는다. 이 경우 ref의 "핸들/손잡이"는 DOM 노드가 아닌, `useImperativeHandle` 호출 안에서 생성한 커스텀 객체이다.

### 리액트가 ref를 붙이는 시점

리액트에서 모든 업데이트는 두 단계로 분리된다.

- **렌더링** 중에 리액트는 컴포넌트를 호출하여 무엇이 화면에 존재해야 하는지 계산한다.
- **커밋** 중에 리액트는 변경 사항을 DOM에 적용한다.

일반적으로 렌더링 중에는 ref에 접근하길 원치 않을 것이다. 이는 ref가 DOM 노드를 가지는 경우에도 마찬가지이다. 초기 렌더링 중에 DOM 노드는 아직 생성되지 않으므로 `ref.current`는 `null`이다. 또한 변경사항을 렌더링하는 중에 DOM 노드는 아직 업데이트되지 않으므로 해당 시점에 노드를 읽는 것은 너무 빠른 일이 될 것이다.

리액트는 커밋 중에 `ref.current`를 설정한다. DOM을 업데이트하기 전에 리액트는 영향을 받는 `ref.current`의 값을 `null`로 설정한다. DOM을 업데이트한 후에 리액트는 즉시 이들을 해당하는 DOM 노드로 설정한다.

> **`flushSync`로 상태 업데이트를 동기적으로 수행하기**  
> 아래 코드는 새로운 투두를 추가하고 리스트의 마지막 자식으로 화면을 스크롤한다. 그러나 어떤 이유로 인해 이 코드는 항상 방금 추가된 아이템의 바로 이전 투두로 스크롤한다.
>
> ```jsx
> import { useState, useRef } from "react";
>
> export default function TodoList() {
>   const listRef = useRef(null);
>   const [text, setText] = useState("");
>   const [todos, setTodos] = useState(initialTodos);
>
>   function handleAdd() {
>     const newTodo = { id: nextId++, text: text };
>     setText("");
>     setTodos([...todos, newTodo]);
>     listRef.current.lastChild.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>     });
>   }
>
>   return (
>     <>
>       <button onClick={handleAdd}>Add</button>
>       <input value={text} onChange={(e) => setText(e.target.value)} />
>       <ul ref={listRef}>
>         {todos.map((todo) => (
>           <li key={todo.id}>{todo.text}</li>
>         ))}
>       </ul>
>     </>
>   );
> }
>
> let nextId = 0;
> let initialTodos = [];
> for (let i = 0; i < 20; i++) {
>   initialTodos.push({
>     id: nextId++,
>     text: "Todo #" + (i + 1),
>   });
> }
> ```
>
> 이슈는 아래 두 줄의 코드에서 발생한다.
>
> ```javascript
> setTodos([...todos, newTodo]);
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 리액트에서 상태의 업데이트는 큐(대기 행렬)를 형성한다. 이는 일반적으로는 문제가 되지 않지만, 위 상황에서는 `setTodos`가 즉시 DOM을 업데이트하지 않아 문제가 생긴다. 즉 리스트를 마지막 엘리먼트로 스크롤하는 시점에 새로운 투두가 아직 추가되지 않은 것이다. 이것이 스크롤이 항상 한 아이템만큼 "뒤쳐지는" 이유이다.  
> 이를 해결하기 위해 리액트가 DOM을 동기적으로 업데이트하도록("씻어내도록, flush") 강제할 수 있다. 우선 `react-dom`에서 `flushSync`를 import 하고, **상태 업데이트를 `flushSync` 호출로 감싸면** 된다.
>
> ```javascript
> flushSync(() => {
>   setTodos([...todos, newTodo]);
> });
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 이는 리액트가 `flushSync`로 감싸진 코드가 실행된 직후에 동기적으로 DOM을 업데이트하도록 지시한다. 결과적으로 마지막 투두는 스크롤을 시도하는 시점에 이미 DOM에 존재하게 된다.

## 이팩트로 동기화하기
