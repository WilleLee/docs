# 비상구

어떤 컴포넌트는 리액트 바깥의 시스템을 제어하거나 거기에 동기화해야 할 수 있다. 가령 브라우저 API를 이용해 인풋을 포커스한다든지, 리액트 없이 구현된 비디오 플레이어를 플레이 또는 중지한다든지, 원격 서버로부터의 메세지를 연결하는 등의 동작이 필요할 수 있다. 이 챕터에서는 리액트 "바깥으로 나가" 외부 시스템과 연결하도록 할 비상구에 대해 배울 것인데, 어플리케이션의 대부분의 로직 및 데이터 흐름은 이러한 특성에 기대지 말아야 한다.

## ref를 이용하여 값 참조하기

컴포넌트가 어떤 정보를 "기억"하기는 하지만 해당 정보가 새로운 렌더링을 촉발하지는 않기를 바라는 경우 **ref**를 사용할 수 있다.

### 컴포넌트에 ref 추가하기

리액트에서 `useRef` 훅을 import 하여 컴포넌트에 ref를 추가할 수 있다.

```jsx
import { useRef } from "react";
```

컴포넌트 안에서 `useRef` 훅을 호출하고 유일한 인자로 원하는 초기값을 전달한다. 가령 아래에서 ref의 값은 `0`이 된다:

```jsx
const ref = useRef(0);
```

`useRef`는 아래와 같은 객체를 반환한다:

```javascript
{
  current: 0, // useRef에 전달한 값
}
```

`ref.current` 프로퍼티를 통해 위 `ref`의 현재 값에 접근할 수 있다. 이 값은 의도적으로 뮤테이션 가능한데, 즉 해당 값을 읽을 수도, 쓸 수도 있다. 이는 리액트가 추적하지 않는 컴포넌트의 비밀 주머니와 같다.

아래 예시에서는 버튼을 클릭할 때마다 `ref.current`의 값이 증가할 것이다:

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

상태와 같이 ref는 어떤 형태의 값이든, 가령 문자열이든 객체이든 심지어는 함수이든 간에 가리킬 수 있다. 상태와 다른 점은 ref가 읽거나 변형할 수 있는 `current` 프로퍼티를 갖는 일반적인 자바스크립트 객체라는 점이다.

**위 `ref.current` 값이 상승할 때 컴포넌트가 리렌더링되지 않는다는 점**에 주목하자. 상태와 같이 ref는 리렌더링 사이에 유지된다. 그러나 상태의 세팅은 컴포넌트를 리렌더링하는 한편 ref의 변경은 그렇지 않다.

### 예시 : 스톱워치 만들기

ref와 상태를 하나의 컴포넌트에서 함께 사용할 수 있다. 예를 들어 버튼을 클릭하여 시작하거나 멈출 수 있는 스톱워치를 만든다고 해보자. 유저가 "Start" 버튼을 누른 후로 얼마나 지났는지 보여주기 위해서는 언제 시작 버튼이 눌렸는지, 그리고 현재 시간은 무엇인지를 추적할 필요가 있다. **이 정보는 렌더링에 이용되므로 상태에 보관해볼 수 있다.**

```jsx
const [startTime, setStartTime] = useState(null);
const [now, setNow] = useState(null);
```

유저가 시작 버튼을 누르면 10 밀리세컨드마다 시간을 업데이트하기 위해 `setInterval`을 사용한다.

```jsx
import { useState } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    // Start counting.
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      // Update the current time every 10ms.
      setNow(Date.now());
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
    </>
  );
}
```

"Stop" 버튼이 눌릴 때 현재 존재하는 인터벌을 멈춰 `now` 상태 변수의 업데이트를 멈춰야 한다. 이는 `clearInterval`을 호출하여 수행할 수 있는데, 이를 위해 유저가 시작 버튼을 누를 때의 `setInterval` 호출로부터 반환되는 인터벌 ID가 필요하다. 그러므로 인터벌 ID를 어딘가에 보관해야 한다. **이때 인터벌 ID는 렌더링에 사용되지 않으므로 ref에 보관해볼 수 있다.**

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

정보의 한 부분이 렌더링에 이용된다면 상태에 보관하면 되고, 만약 이벤트 핸들러에서만 필요하고 해당 정보의 변경이 리렌더링을 필요로 하지 않는다면 ref를 이용하는 것이 더 효율적일 것이다.

### ref와 상태의 차이점

대부분의 경우에서는 상태를 사용하게 되며, ref는 자주 필요하지는 않은 일종의 "비상구"이다. 아래는 상태와 ref를 비교해본 것이다:

| ref                                                                              | 상태                                                                                                  |
| -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `useRef(initialValue)`는 `{ current: initialValue }`를 반환한다.                 | `useState(initialValue)`는 상태 변수의 현재 값과 상태 세터 함수를 반환한다.<br/>(`[value, setValue]`) |
| 변경 시에도 리렌더링을 촉발하지 않는다.                                          | 변경 시 리렌더링을 촉발한다.                                                                          |
| mutable : `current`의 값을 렌더링 프로세스 바깥에서 변경 및 업데이트 할 수 있다. | immutable : 리렌더링 큐를 쌓기 위해 상태 세터 함수를 이용하여 상태 변수를 변경해야만 한다.            |
| 렌더링 시점에 `current` 값을 읽거나 써서는 안 된다.                              | 언제든지 상태를 읽을 수 있다.<br/>다만 각 렌더링 시점은 변하지 않는 고유한 상태 스냅샷을 갖는다.      |

아래 카운터 버튼 예시는 상태와 함께 구현된다.

```jsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return <button onClick={handleClick}>You clicked {count} times</button>;
}
```

`count`의 값이 화면에 보여지기 때문에 이 경우 상태 값을 이용하는 것이 합리적이다. 카운터의 값이 `setCount()`로 변경되면 리액트는 컴포넌트를 리렌더링하고 스크린은 새로운 `count`를 반영하기 위해 업데이트될 것이다.

만약 이를 ref를 이용해 구현하려 했다면 리액트는 결코 컴포넌트를 리렌더링하지 않을 것이므로 카운터가 변화하는 것을 보지 못할 것이다. 이것이 `ref.current`를 렌더링 시에 읽는 일이 신뢰도 떨어지는 코드로 귀결되는 이유이다.

> **내부적으로 `useRef`는 어떻게 동작하는가?**  
> `useState`와 `useRef` 모두 리액트에 의해 제공되기는 하지만, 원칙적으로 `useRef`는 `useState`의 **위에서** 구현될 수 있다. 가령 리액트 내부에서는 `useRef`가 아래와 같이 구현되어 있다고 상상해볼 수 있다:
>
> ```jsx
> // Inside of React
> function useRef(initialValue) {
>   const [ref, unused] = useState({ current: initialValue });
>   return ref;
> }
> ```
>
> 초기 렌더링 시에 `useRef`는 `{ current: initialValue }`를 반환한다. 이 객체는 리액트에 저장되므로 다음 렌더링 시에 동일한 객체가 반환될 것이다. 이 예시에서 상태 세터가 이용되지 않는다는 점에 유의하자. 이는 불필요한데, 왜냐하면 `useRef`가 항상 동일한 객체를 반환할 필요가 있기 때문이다.

### 언제 ref를 이용해야 할까?

일반적으로 ref는 컴포넌트가 리액트 "바깥으로 나가" 외부 API들, 가령 컴포넌트의 외형에 영향을 주지 않는 브라우저 API와 소통해야 할 때 사용된다. 아래는 이런 몇 안 되는 상황들의 예시이다:

- 타임아웃 ID의 저장
- DOM 엘리먼트의 저장 및 조작
- JSX 계산에는 필요하지 않은 다른 객체들의 저장

만약 컴포넌트가 어떤 값을 저장하는데, 이 값이 렌더링 로직에는 영향을 주지 않는다면 ref를 선택하는 것이 바람직하다.

### 최적의 ref 사용법

아래 원칙들을 따름으로써 보다 예측 가능한 컴포넌트를 만들 수 있다:

- ref를 일종의 비상구처럼 다루기  
  ref는 외부 시스템이나 브라우저 API를 이용할 때 유용하다. 만약 앱의 로직 및 데이터 흐름의 많은 부분이 ref에 의존한다면, 접근 방식에 대해 다시 생각해볼 필요가 있을 것이다.
- 렌더링 중에 `ref.current`를 읽거나 쓰지 않기  
  렌더링 중에 어떤 정보가 필요하다면 ref가 아닌 상태를 이용하자. 리액트는 언제 `ref.current`가 변화하는지 알지 못하므로, 렌더링 중에 `ref.current`를 읽어들이는 일조차도 컴포넌트의 동작을 예측하기 어렵게 할 것이다.

리액트 상태의 한계는 ref에 적용되지 않는다. 가령 상태는 매 렌더링 시에 스냅샷처럼 행동하고 동기적으로 업데이트하지는 않는 반면, ref의 현재 값을 뮤테이션하면 그 값은 그 즉시 변경된다.

```javascript
ref.current = 5;
console.log(ref.current); // 5
```

이는 **ref 자신이 일반 자바스크립트 객체**이며 그와 같이 행동하기 때문이다.

또한 ref를 이용하는 중에는 뮤테이션을 피해야 한다는 걱정을 할 필요가 없다. 뮤테이션 되는 객체가 렌더링에 이용되지 않는 한, 리액트는 ref나 그것의 컨텐츠에 어떤 일이 일어나든 신경쓰지 않는다.

### ref와 DOM

ref로는 어떤 형태의 값이든 가리킬 수 있지만, ref를 이용하는 가장 일반적인 유즈케이스는 DOM 엘리먼트에 접근하는 일이다. 가령 어떤 인풋에 프로그래밍적으로 포커스하기를 원한다면 이는 매우 유용할 것이다. `<div ref={myRef}>`와 같이 ref를 JSX의 `ref` 속성에 전달하면, 리액트는 해당하는 DOM 엘리먼트를 `myRef.current`에 저장할 것이다. 그 엘리먼트가 DOM에서 삭제되는 순간 리액트는 `myRef.current`를 `null`로 업데이트할 것이다.

## ref를 이용해 DOM 조작하기

리액트가 자동으로 DOM을 업데이트하여 렌더링 아웃풋과 일치시키기 때문에 컴포넌트는 대부분의 경우 DOM을 직접 조작할 필요가 없다. 그러나 어떤 경우에는 리액트가 관리하는 DOM 엘리먼트에 대한 접근 권한이 필요할 수 있는데, 가령 특정 노드를 포커스하거나, 거기로 스크롤하거나, 노드의 사이즈 또는 위치를 측정하거나 하는 경우 그렇다. 리액트에 그런 일을 수행할 방법이 내장되어 있지 않기 때문에 이 경우 DOM 노드에 대한 **ref**가 필요하다.

### 노드에 대한 ref 얻기

리액트에 의해 관리되는 DOM 노드에 접근하기 위해서는 우선 `useRef` 훅을 import 해야 한다. 그런 후 이를 이용해 컴포넌트 안에서 ref를 선언한다. 끝으로는 ref를 DOM 노드를 취하고자 하는 JSX 태그에 `ref` 속성으로 전달한다.

```jsx
<div ref={myRef} />
```

`useRef` 훅은 `current`라고 불리는 하나의 프로퍼티를 갖는 객체를 반환한다. 초기에 `myRef.current`는 `null`이다. 리액트가 이 `<div>`에 대한 DOM 노드를 생성하면, 리액트는 이 노드에 대한 참조를 `myRef.current`에 저장한다. 그러면 이벤트 핸들러를 이용해 해당 DOM 노드에 접근할 수 있게 되며, 그에 대해 정의된 빌트인 브라우저 API들을 사용할 수 있게 된다.

```javascript
// 어떤 브라우저 API든 사용할 수 있다. 가령:
myRef.current.scrollIntoView();
```

### 예시 : 텍스트 인풋 포커스하기

아래 예시에서 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이를 구현하기 위해:

1. `useRef` 훅으로 `inputRef`를 선언한다.
2. 이를 `<input ref={inputRef}>` 형태로 전달한다. 이로써 리액트는 **이 `<input>`의 DOM 노드를 `inputRef.current`에 집어넣는다.**
3. `handleClick` 함수에서 `inputRef.current`를 통해 인풋 DOM 노드를 읽고, `inputRef.current.focus()`와 같이 해당 DOM 노드의 `focus()` 매서드를 호출한다.
4. `onClick`을 이용해 `handleClick` 이벤트 핸들러를 `<button>`에 전달한다.

DOM을 조작하는 것이 ref의 가장 일반적인 유즈케이스이긴 하지만, `useRef` 훅은 타이머 ID와 같은, 리액트 바깥의 많은 것들을 보관하는 데 사용될 수 있다. 상태와 유사하게 ref는 렌더링 중에 유지된다. ref는 변경 시 리렌더링을 촉발하지 않는 상태 변수라고 할 수 있겠다.

### 예시 : 특정 엘리먼트로 스크롤하기

하나의 컴포넌트 안에 다수의 ref를 포함시킬 수 있다. 아래 예시에는 세 가지 이미지의 캐러셀이 있다. 각각의 버튼은 해당하는 DOM 노드의 `scrollIntoView()` 브라우저 매서드를 호출하여 이미지를 가운데에 위치시킨다:

```jsx
import { useRef } from "react";

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>Tom</button>
        <button onClick={handleScrollToSecondCat}>Maru</button>
        <button onClick={handleScrollToThirdCat}>Jellylorum</button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placekitten.com/g/200/200"
              alt="Tom"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/300/200"
              alt="Maru"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placekitten.com/g/250/200"
              alt="Jellylorum"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}
```

> `ref` 콜백을 이용하여 ref들의 리스트를 관리하는 방법  
> 위 예시에서는 ref의 수가 사전에 정의되어 있다. 하지만 어떤 경우에는 특정 리스트의 각 아이템에 대한 ref의 선언이 필요하기는 하지만 아이템의 수는 알지 못할 수도 있다. 이때 아래와 같은 로직은 **작동하지 않을 것**이다.
>
> ```jsx
> <ul>
>   {items.map((item) => {
>     // Doesn't work!
>     const ref = useRef(null);
>     return <li ref={ref} />;
>   })}
> </ul>
> ```
>
> 이는 **훅은 반드시 컴포넌트의 최상단에서만 호출되어야** 하기 때문이다. 반복문이나 조건문, `map()` 호출 내부에서는 `useRef`를 호출할 수 없다.  
> 이와 관련해 적용해볼 수 있는 한 가지 방법은 부모 엘리먼트에 대한 하나의 ref를 가져와 `querySelectorAll`과 같은 DOM 조작 매서드를 사용하여 개별적인 자식 노드를 "찾아내는" 것이다. 하지만 이는 다루기 힘들고, DOM 구조가 변한다면 더 이상 작동하지 않을 수 있다.  
> 또 다른 해결 방법은 **`ref` 속성에 함수를 전달**하는 것이다. 이러한 일을 **`ref` 콜백**이라 한다. 리액트는 ref를 설정할 때에는 `ref` 콜백을 DOM 노드와 함께 호출하고, ref를 비울 때에는 `ref` 콜백을 `null`과 함께 호출한다. 이를 통해 어떤 배열이나 Map을 유지할 수 있으며, 어떤 ref에 대해 그것의 인덱스 값이나 특정한 ID를 통해 접근할 수 있게 된다.  
> 아래 예시는 이러한 접근법을 긴 리스트의 임의의 노드로 스콜하는 데 어떻게 이용할 수 있는지 보여준다:
>
> ```jsx
> import { useRef } from "react";
>
> export default function CatFriends() {
>   const itemsRef = useRef(null);
>
>   function scrollToId(itemId) {
>     const map = getMap();
>     const node = map.get(itemId);
>     node.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>       inline: "center",
>     });
>   }
>
>   function getMap() {
>     if (!itemsRef.current) {
>       // Initialize the Map on first usage.
>       itemsRef.current = new Map();
>     }
>     return itemsRef.current;
>   }
>
>   return (
>     <>
>       <nav>
>         <button onClick={() => scrollToId(0)}>Tom</button>
>         <button onClick={() => scrollToId(5)}>Maru</button>
>         <button onClick={() => scrollToId(9)}>Jellylorum</button>
>       </nav>
>       <div>
>         <ul>
>           {catList.map((cat) => (
>             <li
>               key={cat.id}
>               ref={(node) => {
>                 const map = getMap();
>                 if (node) {
>                   map.set(cat.id, node);
>                 } else {
>                   map.delete(cat.id);
>                 }
>               }}
>             >
>               <img src={cat.imageUrl} alt={"Cat #" + cat.id} />
>             </li>
>           ))}
>         </ul>
>       </div>
>     </>
>   );
> }
>
> const catList = [];
> for (let i = 0; i < 10; i++) {
>   catList.push({
>     id: i,
>     imageUrl: "https://placekitten.com/250/200?image=" + i,
>   });
> }
> ```
>
> 이 예시에서 `itemsRef`는 하나의 DOM노드를 붙들고 있지 않는다. 대신에 아이템의 ID에서 DOM 노드로의 Map을 저장한다. 모든 리스트 내 아이템에 대한 `ref` 콜백은 이 Map을 업데이트하는 것에만 신경쓴다.
>
> ```jsx
> <li
>   key={cat.id}
>   ref={node => {
>     const map = getMap();
>     if (node) {
>       // Add to the Map
>       map.set(cat.id, node);
>     } else {
>       // Remove from the Map
>       map.delete(cat.id);
>     }
>   }}
> >
> ```
>
> 이로써 후에 Map으로부터 개별 DOM 노드를 읽을 수 있게 된다.

### 다른 컴포넌트의 DOM 노드에 접근하기

ref를 `<input />` 같은 브라우저 엘리먼트를 반환하는 빌트인 컴포넌트에 놓으면, 리액트는 그 ref의 `current` 프로퍼티를 해당하는 DOM 노드로 설정한다.

그러나 만약 ref를 **직접 만든** 컴포넌트에 놓으면, 디폴트로 `null`을 얻게 될 것이다. 아래 예시에서 버튼을 클릭하는 일은 인풋에 포커스 이벤트를 일으키지 **않는다**.

```jsx
import { useRef } from "react";

function MyInput(props) {
  return <input {...props} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

이런 일이 일어나는 이유는 기본적으로 리액트가 컴포넌트로 하여금 다른 컴포넌트의 DOM 노드에 접근하지 못하게 하기 때문이다. 그 자신의 직접적인 `children`일지라도 말이다. 이는 의도된 것인데, ref는 하나의 비상구로서 오직 한정적으로만 사용되어야 한다. 임의로 **다른** 컴포넌트의 DOM 노드를 조작하는 것은 많은 오류를 낳을 수 있다.

대신에 자신의 DOM 노드를 바깥에 노출시키기를 **원하는** 컴포넌트들은 해당 동작에 **동의해야**(opt in) 한다. 컴포넌트는 자신의 ref를 자신의 `children` 중 하나에 "전달할"(forward) 것임을 특정할 수 있다. 아래는 어떻게 `<MyInput>`이 `forwardRef` API를 이용하여 이를 수행하는지 보여준다:

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});
```

이것의 작동 방식은 아래와 같다:

1. `<MyInput ref={inputRef}>`는 리액트에게, 해당하는 DOM 노드를 `inputRef.current`에 놓으라고 말한다. 그러나 여기에 동의하는/참석하는 일은 `<MyInput>` 컴포넌트에게 달려있다.
2. `<MyInput>` 컴포넌트는 `forwardRef`를 이용해 선언되었다. **이는 상위 컴포넌트로부터 `inputRef`를 두 번째 ref 인자(props 뒤에 선언된다)로 받기를 동의하도록 한다.**
3. `<MyInput>` 자신은 전달받은 ref를 내부의 `<input>`에 전달한다.

이제 버튼을 클릭하면 인풋에 포커스가 일어난다.

```jsx
import { forwardRef, useRef } from "react";

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

디자인 시스템에서는 버튼이나 인풋 같은 하위 레벨 컴포넌트들이 자신들의 ref를 아래 DOM 노드로 전달하는 것이 일반적인 패턴이다. 다른 한편 폼이나 리스트, 페이지 섹션 같은 상위 레벨 컴포넌트는 자신들의 DOM 노드를 노출시키지 않음으로써 DOM 구조의 우연스러운 의존성을 피한다.

> **명령형 핸들을 이용하여 API의 서브셋을 노출시키기**  
> 위 예시에서 `<MyInput>`은 오리지널 DOM 인풋 엘리먼트를 노출시켜 부모 컴포넌트가 그에 대한 `focus()`를 호출할 수 있도록 하기도 하지만, 인풋의 CSS를 변경하는 등과 다른 일들을 수행할 수 있도록 할 수도 있다. 일반적인 일은 아니지만 이렇게 노출되는 기능성을 제한하고자 할 수도 있는데, 이때는 `useImperativeHandle` 훅을 이용할 수 있다.
>
> ```jsx
> import { forwardRef, useRef, useImperativeHandle } from "react";
>
> const MyInput = forwardRef((props, ref) => {
>   const realInputRef = useRef(null);
>   useImperativeHandle(ref, () => ({
>     // Only expose focus and nothing else
>     focus() {
>       realInputRef.current.focus();
>     },
>   }));
>   return <input {...props} ref={realInputRef} />;
> });
>
> export default function Form() {
>   const inputRef = useRef(null);
>
>   function handleClick() {
>     inputRef.current.focus();
>   }
>
>   return (
>     <>
>       <MyInput ref={inputRef} />
>       <button onClick={handleClick}>Focus the input</button>
>     </>
>   );
> }
> ```
>
> 여기서 `<MyInput>` 내의 `realInputRef`는 실제 인풋 DOM 노드를 갖는다. 하지만 `useImperativeHandle`은 리액트로 하여금 ref 값이 될 고유의 특별한 객체를 부모 컴포넌트에 제공하도록 지시한다. 따라서 `<Form>` 컴포넌트 내의 `inputRef.current`는 `focus` 매서드만을 갖는다. 이 경우 ref의 "핸들/손잡이"는 DOM 노드가 아닌, `useImperativeHandle` 호출 안에서 생성한 커스텀 객체이다.

### 리액트가 ref를 붙이는 시점

리액트에서 모든 업데이트는 두 단계로 분리된다.

- **렌더링** 중에 리액트는 컴포넌트를 호출하여 무엇이 화면에 존재해야 하는지 계산한다.
- **커밋** 중에 리액트는 변경 사항을 DOM에 적용한다.

일반적으로 렌더링 중에는 ref에 접근하길 원치 않을 것이다. 이는 ref가 DOM 노드를 가지는 경우에도 마찬가지이다. 초기 렌더링 중에 DOM 노드는 아직 생성되지 않으므로 `ref.current`는 `null`이다. 또한 변경사항을 렌더링하는 중에 DOM 노드는 아직 업데이트되지 않으므로 해당 시점에 노드를 읽는 것은 너무 빠른 일이 될 것이다.

리액트는 커밋 중에 `ref.current`를 설정한다. DOM을 업데이트하기 전에 리액트는 영향을 받는 `ref.current`의 값을 `null`로 설정한다. DOM을 업데이트한 후에 리액트는 즉시 이들을 해당하는 DOM 노드로 설정한다.

> **`flushSync`로 상태 업데이트를 동기적으로 수행하기**  
> 아래 코드는 새로운 투두를 추가하고 리스트의 마지막 자식으로 화면을 스크롤한다. 그러나 어떤 이유로 인해 이 코드는 항상 방금 추가된 아이템의 바로 이전 투두로 스크롤한다.
>
> ```jsx
> import { useState, useRef } from "react";
>
> export default function TodoList() {
>   const listRef = useRef(null);
>   const [text, setText] = useState("");
>   const [todos, setTodos] = useState(initialTodos);
>
>   function handleAdd() {
>     const newTodo = { id: nextId++, text: text };
>     setText("");
>     setTodos([...todos, newTodo]);
>     listRef.current.lastChild.scrollIntoView({
>       behavior: "smooth",
>       block: "nearest",
>     });
>   }
>
>   return (
>     <>
>       <button onClick={handleAdd}>Add</button>
>       <input value={text} onChange={(e) => setText(e.target.value)} />
>       <ul ref={listRef}>
>         {todos.map((todo) => (
>           <li key={todo.id}>{todo.text}</li>
>         ))}
>       </ul>
>     </>
>   );
> }
>
> let nextId = 0;
> let initialTodos = [];
> for (let i = 0; i < 20; i++) {
>   initialTodos.push({
>     id: nextId++,
>     text: "Todo #" + (i + 1),
>   });
> }
> ```
>
> 이슈는 아래 두 줄의 코드에서 발생한다.
>
> ```javascript
> setTodos([...todos, newTodo]);
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 리액트에서 상태의 업데이트는 큐(대기 행렬)를 형성한다. 이는 일반적으로는 문제가 되지 않지만, 위 상황에서는 `setTodos`가 즉시 DOM을 업데이트하지 않아 문제가 생긴다. 즉 리스트를 마지막 엘리먼트로 스크롤하는 시점에 새로운 투두가 아직 추가되지 않은 것이다. 이것이 스크롤이 항상 한 아이템만큼 "뒤쳐지는" 이유이다.  
> 이를 해결하기 위해 리액트가 DOM을 동기적으로 업데이트하도록("씻어내도록, flush") 강제할 수 있다. 우선 `react-dom`에서 `flushSync`를 import 하고, **상태 업데이트를 `flushSync` 호출로 감싸면** 된다.
>
> ```javascript
> flushSync(() => {
>   setTodos([...todos, newTodo]);
> });
> listRef.current.lastChild.scrollIntoView();
> ```
>
> 이는 리액트가 `flushSync`로 감싸진 코드가 실행된 직후에 동기적으로 DOM을 업데이트하도록 지시한다. 결과적으로 마지막 투두는 스크롤을 시도하는 시점에 이미 DOM에 존재하게 된다.

## 이팩트로 동기화하기

어떤 컴포넌트는 외부 시스템에 동기화되어야 한다. 가령 컴포넌트가 화면에 나타났을 때, 리액트 상태에 기반하여 비리액트(non-React) 컴포넌트를 제어하거나 서버 연결을 설정하거나 분석 로그를 보내는 등의 일을 수행해야 할 수 있다. **이팩트**는 렌더링 이후에 특정 코드를 실행하게 하여 컴포넌트를 리액트 외부의 시스템에 동기화시킬 수 있게 한다.

### 이팩트란 무엇이고 이벤트와는 어떻게 다른가?

이팩트에 대해 알아보기 전에 리액트 컴포넌트 내부 로직의 두 가지 유형에 대해 이해할 필요가 있다:

- **렌더링 코드**(UI의 묘사)는 컴포넌트의 최상위에 존재한다. 여기서 props와 상태를 취하고, 이들을 변형시키며, 화면에서 보고자 하는 JSX를 반환한다. 렌더링 코드는 반드시 순수해야 한다. 마치 수학 공식처럼, 렌더링 코드는 결과물을 **계산하는** 것 외의 어떤 일도 수행해서는 안 된다.
- **이벤트 핸들러**(상호작용의 추가)는 컴포넌트 내의 네스팅된 함수로, 어떤 것을 계산하기보다는 **수행한다**. 이벤트 핸들러는 인풋 필드를 업데이트하거나, 상품을 구매하기 위한 HTTP `POST` 리퀘스트를 제출하거나, 유저를 다른 화면으로 네비게이션시키는 등의 일을 수행할 수 있다. 이벤트 핸들러는 특정 유저 액션(버튼 클릭이나 타이핑 같은 것들)에 의한 "사이드 이팩트"(프로그램의 상태를 변경)를 포함한다.

그러나 이걸로는 충분하지 않은 경우가 있을 수 있다. 가령 화면에 보일 때마다 채팅 서버에 연결되어야 하는 `<ChatRoom />` 컴포넌트를 생각해보자. 서버에 연결하는 일은 순수한 계산이 아니므로(사이드 이팩트이므로), 렌더링 중에 일어날 수는 없다. 그렇다고 클릭과 같은 특정한 이벤트로 인해 `<ChatRoom />`이 보여지는 것도 아니다.

**이팩트는 특정 이벤트보다는 렌더링 자체로 인해 발생하는 사이드 이팩트를 명시하도록 한다.** 메시지를 보내는 일은 유저가 특정 버튼을 누르는 행위로부터 직접적으로 촉발되는 것이므로 하나의 이벤트이다. 이와 달리 서버 연결을 설정하는 일은 이팩트이다. 왜냐하면 이는 어떤 상호작용에 의해 컴포넌트가 나타났는가 하는 것과는 상관 없이 일어나는 일이기 때문이다. 이팩트는 화면이 업데이트된 이후, 커밋의 가장 마지막 단계에 실행되는데, 이는 외부 시스템에 리액트 컴포넌트를 동기화하기에 좋은 시점이기 때문이다.

> 여기서 대문자 "Effect"는 리액트 특유의 정의, 즉 렌더링에 의한 사이드 이팩트를 나타낸다. 더 넓은 프로그래밍적 개념을 나타낼 때에는 "side effect"라 하겠다.

### 이팩트가 필요하지 않을 수 있다

**컴포넌트에 이팩트를 추가하는 데 급급해서는 안 된다.** 이팩트는 일반적으로 리액트 코드로부터 "벗어나" 어떤 "외부의" 시스템과 동기화하는 데 이용된다. 만약 어떤 이팩트가 어떤 상태에 기반하여 다른 상태를 조정하는 일만을 수행한다면, 이 경우 이팩트는 필요하지 않을 수 있다.

### 이팩트를 작성하는 방법

이팩트를 작성하기 위해서는 아래 세 가지 스텝을 따라야 한다:

1. **이팩트 선언하기** : 기본적으로 이팩트는 매 렌더링 이후에 실행된다.
2. **이팩트 의존성 명시하기** : 대부분의 이팩트는 매 렌더링 이후가 아니라, **필요한 경우에** 재실행되어야 한다.
3. **필요에 따라 클린업 추가하기** : 어떤 이팩트에서는 그것이 수행하던 일을 중지, 취소 또는 클린업하는 방식을 명시해야 할 수 있다.

#### 스텝 1. 이팩트 선언하기

이팩트를 선언하기 위해서는 리액트로부터 `useEffect` 훅을 import 해야 한다.

```javascript
import { useEffect } from "react";
```

그런 후 컴포넌트의 최상위에서 훅을 호출하고, 이팩트 안에 코드를 집어넣는다.

```tsx
function MyComponent() {
  useEffect(() => {
    // 이곳의 코드는 *매* 렌더링마다 실행될 것이다.
  });
  return <div />;
}
```

컴포넌트가 렌더링될 때마다 리액트는 화면을 업데이트한 **이후에** `useEffect` 안의 코드를 실행한다. 달리 표현하면 **`useEffect`는 렌더링 결과물이 화면에 반영되기까지 일부 코드의 실행을 "지연시킨다".**

어떻게 이팩트를 사용하여 외부 시스템과 동기화할 수 있는지 살펴보자. `<VideoPlayer>`라는 리액트 컴포넌트를 생각해보면, `isPlaying`이라는 prop을 전달하여 비디오의 재생 여부를 제어할 수 있으면 좋을 것이다:

```tsx
<VideoPlayer isPlaying={isPlaying} />
```

커스텀 `<VideoPlayer />` 컴포넌트는 빌트인 브라우저 태그인 `<video>`를 렌더링한다:

```tsx
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```

그러나 브라우저의 `<video>` 태그는 `isPlaying` prop을 갖지 않는다. 이를 제어하는 유일한 방법은 수동으로 DOM 엘리먼트의 `play()`, `pause()` 매서드를 실행하는 것이다. 이때 **비디오가 현재 재생 중*이어야만 하는지* 여부를 말해주는 `isPlaying` prop 값을, `play()` 또는 `pause()` 매서드의 호출과 동기화시켜야 한다.**

우선은 `<video>` DOM 노드에 대한 ref를 얻어야 한다. 렌더링 중에 `play()`나 `pause()`를 호출해볼 수 있겠으나, 이는 올바른 방법이 아니다:

```tsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play(); // 렌더링 중에 이를 호출하는 일은 허용되지 않는다.
  } else {
    ref.current.pause(); // 이 부분도 에러를 일으킨다.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

위 코드가 올바르지 않은 이유는 렌더링 도중에 DOM 노드를 이용하여 무언가 하려 하기 때문이다. 리액트에서 렌더링은 JSX의 순수한 계산이어야 하며, DOM의 변형과 같은 사이드 이팩트를 포함해서는 안 된다.

더 나아가 `<VideoPlayer />`가 처음 호출되는 시점에 해당 DOM은 아직 존재하지 않는다. `play()`나 `pause()`를 호출할 DOM 노드가 아직 존재하지 않는 것인데, 이는 JSX가 반환되기까지 리액트가 어떤 DOM을 생성해야 할지 알지 못하기 때문이다.

여기서 해결방안은 **사이드 이팩트를 `useEffect`로 감싸서 렌더링 계산 바깥으로 이동시키는 것**이다.

```tsx
import { useEffect, useRef } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

DOM 업데이트를 이팩트로 감싸서 리액트가 화면을 먼저 업데이트하도록(커밋하도록) 하고, 그 이후에 이팩트가 실행되도록 할 수 있다.

`<VideoPlayer />`가 렌더링될 때(초기 렌더링이든 리렌더링이든) 몇 가지 일이 일어난다. 첫째로 리액트가 화면을 업데이트하여 `<video>` 태그가 적절한 props와 함께 DOM에 존재하도록 한다. 그 다음 리액트는 이팩트를 실행한다. 마지막으로 이팩트가 `isPlaying`의 값에 따라 `play()`나 `pause()`를 호출한다.

#### 스텝 2. 이팩트 의존성 명시하기

기본적으로 이팩트는 **매** 렌더링 이후에 실행된다. 하지만 많은 경우 이는 **개발 의도에 부합하지 않는다**.

`useEffect` 호출에 두 번째 인자로 **의존성**의 배열을 명시함으로써 **이팩트를 불필요하게 재실행하는 것을 생략**하도록 할 수 있다. 우선 빈 `[]` 배열을 추가해보자:

```typescript
useEffect(() => {
  // ...
}, []);
```

이때 `React Hook useEffect has a missing dependency: 'isPlaying'`이라는 에러를 볼 수 있다:

```tsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log("Calling video.play()");
      ref.current.play();
    } else {
      console.log("Calling video.pause()");
      ref.current.pause();
    }
  }, []); // 여기서 에러가 발생한다.

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState("");
  return (
    <>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

여기서 문제는, 이팩트 안의 코드가 어떤 일을 수행할지 결정하는 데 있어서 `isPlaying` prop에 **의존하고** 있지만, 이러한 의존성이 명시적으로 선언되지 않았다는 데 있다. 이를 해결하려면 `isPlaying`을 의존성 배열에 추가해야 한다:

```typescript
useEffect(() => {
  if (isPlaying) {
    // 여기에서 사용되었으므로…
    // ...
  } else {
    // ...
  }
}, [isPlaying]); // …여기에 반드시 선언되어야 한다!
```

이제 모든 의존성이 선언되었으므로 에러는 발생하지 않는다. 의존성 배열로 `[isPlaying]`을 명시하는 일은 리액트에게 `isPlaying`이 이전 렌더링 시의 값과 동일하다면 해당 이팩트의 재실행을 건너뛰라고 얘기하는 것과 같다.

의존성 배열은 다수의 의존성을 포함할 수 있다. 리액트는 명시된 의존성이 **모두** 이전 렌더링 시점의 값과 정확히 일치할 때에만 이팩트의 재실행을 스킵한다. 리액트는 `Object.is` 비교를 이용해 의존성 값들을 비교한다.

이때 **의존성을 "선택"할 수는 없다는 점에 유의하자.** 만약 명시한 의존성이 이팩트 내의 코드에 기반하여 리액트가 예상한 의존성과 일치하지 않는다면 린트 에러가 발생할 것이다. 이는 코드의 많은 버그를 잡아내는 데 유용하다.

> **주의**  
> 의존성 배열이 없는 것과 빈 `[]` 의존성 배열을 갖는 것은 다르게 동작한다:
>
> ```typescript
> useEffect(() => {
>   // 모든 렌더링마다 실행된다.
> });
>
> useEffect(() => {
>   // 마운트 시에만(컴포넌트가 나타날 때) 실행된다.
> }, []);
>
> useEffect(() => {
>   // 마운트 시 *뿐만 아니라* a 또는 b가 이전 렌더링 이후 변경되었을 때 실행된다.
> }, [a, b]);
> ```

> **왜 ref는 의존성 배열에서 생략되는가?**  
> 위 이팩트는 `ref`와 `isPlaying`을 **모두** 사용하지만, `isPlaying`만이 의존성으로 선언된다. 이는 ref 객체가 **안정적 아이덴티티**를 갖기 때문인데, 리액트는 매 렌더링마다 동일 `useRef` 호출로부터 동일한 객체를 항상 얻을 것임을 보증한다. 절대 변화하지 않으므로 그 자체로서는 이팩트의 재실행을 유도하지 않는 것이다. 따라서 `ref`를 포함시키는 여부는 아무런 문제가 되지 않는다.  
> 항시 안정적인 의존성을 생략하는 일은 린트가 해당 객체가 안정적임을 **볼** 수 있을 때에만 가능하다. 가령 어떤 ref가 부모 컴포넌트로부터 전달된다면, 이것은 의존성 배열에 명시되어야 한다. 이는 나쁘기만 한 것은 아닌데, 왜냐하면 부모 컴포넌트가 항상 동일한 ref를 보내는지, 혹은 여러 ref 중 하나를 조건적으로 보내는지 알 수 없기 때문이다.

#### 스텝 3. 필요에 따라 클린업 추가하기

다른 예시로, 화면에 나타날 때 채팅 서버에 연결되어야 하는 `<ChatRoom />` 컴포넌트를 생각해보자. `connect()`와 `disconnect()` 매서드를 갖는 객체를 반환하는 `createConnection()` API가 주어진다면, 어떻게 컴포넌트가 유저에게 보여지는 동안 연결을 유지할 수 있을까?

우선 이팩트 로직을 작성하는 데에서 시작해보자:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
});
```

매 렌더링 시마다 채팅 서버에 연결하는 것은 느릴 수 있으니 의존성 배열을 추가하는 것이 좋겠다:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);
```

**이팩트 내의 코드가 어떤 props나 상태도 이용하지 않으므로 이때의 의존성 배열은 `[]`이다. 이것은 리액트에게 해당 코드를 컴포넌트가 "마운트"할 때에만, 즉 화면에 처음으로 나타날 때에만 실행하라고 말하는 것과 같다.**

그럼 이 코드를 실행해보자:

```tsx
import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

이 이팩트는 마운트 시에만 실행되므로 콘솔에 `✅ Connecting…`이 한 번만 출력될 것으로 예상할 수 있다. **하지만 콘솔을 확인해보면 `✅ Connecting…`이 두 번 출력된다.**

`<ChatRoom />` 컴포넌트가 여러 다른 화면을 가진 커다란 앱의 일부분이라 생각해보자. 유저가 `<ChatRoom />` 페이지에 방문하면 컴포넌트가 마운트하고 `connection.connect()`가 호출된다. 이후 유저가 다른 화면으로 이동하면 `<ChatRoom />`은 언마운트한다. 그리고 유저가 뒤로가기 버튼을 누르면 `<ChatRoom />`이 다시 마운트할텐데, 이는 두 번째 연결을 설정하겠지만, 이전의 첫 번째 연결은 끊어지지 않은 상태이다. 유저가 앱의 이곳저곳을 네비게이션할수록 서버 연결은 계속해서 중첩될 것이다.

이러한 버그를 찾아내는 데 도움을 주기 위해 개발 모드에서 리액트는 모든 컴포넌트를 초기 마운트 바로 직후에 한 번 더 리마운트한다.

위에서 `✅ Connecting...` 로그가 두 번 나타나는 것은 실제 이슈, 즉 기존 코드가 컴포넌트 언마운트 시에 연결을 끊지 않는다는 것을 확인시켜준다.

이를 해결하기 위해 이팩트로부터 **클린업 함수**를 반환해야 한다:

```typescript
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

리액트는 이팩트가 재실행될 때마다, 그리고 마지막으로는 컴포넌트가 언마운트할 때(제거될 때), 클린업 함수를 호출한다.

이제 개발 모드에서 세 개의 콘솔 로그를 보게 될 것이다:

1. `✅ Connecting…`
2. `❌ Disconnected!`
3. `✅ Connecting…`

**개발 모드에서 이는 정상적인 동작이다.** 컴포넌트를 리마운트함으로써 리액트는 해당 네비게이션을 왔다갔다 수행하는 일이 코드를 망가뜨리지 않는지 검증한다. 연결을 끊었다가 재연결하는 것은 분명 일어나야만 하는 일이라는 것이다. 클린업을 잘 구현한다면 이팩트를 한 번만 실행하는 것과 실행했다가 클린업 했다가 다시 실행하는 것 사이에서 유저가 볼 수 있는 차이점은 없을 것이다.

**프로덕션 모드에서는 `✅ Connecting...`이 한 번만 출력될 것이다.** 컴포넌트의 리마운트는 개발 모드에서만 일어나 클린업의 필요성을 확인하는 데 도움을 준다.

### 개발 모드에서 두 번 실행되는 이팩트를 어떻게 핸들링할까?

리액트는 개발 모드에서 컴포넌트를 의도적으로 리마운트하여 이전 예시에서와 같은 버그를 찾아낸다. **여기서 해야만 하는 질문은 "어떻게 하면 이팩트를 한 번만 실행할 수 있나요?"가 아니라, "어떻게 이팩트를 수정하면 리마운트 이후에도 정상 작동할까요?"이다.**

보통의 경우 해답은 클린업 함수를 구현하는 것이다. 이때 클린업 함수는 이팩트가 수행하는 것을 그것이 무엇이든 간에 중지 또는 취소해야 한다.

작성하게 될 이팩트의 대부분은 아래의 일반적인 패턴 중 하나를 따를 것이다.

#### 리액트 컴포넌트가 아닌 위젯 제어하기

#### 이벤트 구독하기

이팩트가 무언가를 구독한다면, 클린업 함수는 이 구독을 해제해야 한다.

```typescript
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

개발 모드에서 이팩트는 동일 핸들러에 대해서 `addEventListener()`를 호출한 다음 즉시 `removeEventListener()`를 호출하고, 다시 `addEventListener()`를 호출한다. 그로 인해 동시에 오직 하나의 구독만이 있게 된다. 이는 프로덕션 모드에서 `addEventListener()`를 한 번만 호출하는 것과 동일한 동작을 보인다.

#### 애니메이션 시작하기

이팩트가 어떤 애니메이션을 추가한다면, 클린업 함수는 해당 애니메이션을 원래 값으로 되돌려야 한다.

```typescript
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

개발 모드에서 투명도는 1로 설정되었다가 0으로, 그리고 다시 1로 설정될 것이다. 이는 직접적으로 1로 설정하는 것과 동일한 동작을 보여야 한다.

#### 데이터 패치하기

만약 이팩트가 어떤 데이터를 패치한다면, 클린업 함수는 해당 패치를 중지하거나 그 결과를 무시해야 한다.

```typescript
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

이미 일어난 네트워크 요청을 "취소할" 수는 없지만, 클린업 함수는 **더 이상 관련성을 갖지 않는** 패치가 어플리케이션에 계속해서 영향을 미치지 않을 것임을 보장해야 한다. 만약 `userId`가 `"Alice"`에서 `"Bob"`으로 변경되었다면, 클린업은, 혹여나 `"Bob"`으로 요청한 리스펀스가 먼저 도착했을지라도, `"Alice"`로 요청한 리스펀스를 무시하도록 해야 한다.

**개발 모드에서는 네트워크 탭에서 두 개의 패치를 보게 될 것이다.** 위의 접근법에서 첫 번째 이팩트는 즉시 클린업되어 그 안의 `ignore` 변수는 `true`로 설정된다. 따라서 추가적인 리퀘스트가 발생하더라도 `if (!ignore)` 표현을 통한 확인으로 인해 상태는 영향을 받지 않을 것이다.

#### 애널리틱스 보내기

#### 이팩트가 아닌 경우 : 애플리케이션의 초기 설정 수행하기

어플리케이션이 시작할 때에만 일회성으로 실행되어야 하는 로직이 있을 수 있다. 이러한 로직은 컴포넌트 바깥에 위치시킬 수 있다:

```tsx
if (typeof window !== "undefined") {
  // 코드가 브라우저에서 실행되었는지 체크함
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

이는 해당 로직이 브라우저가 페이지를 로드한 이후 단 한 번만 실행되도록 한다.

#### 이팩트가 아닌 경우 : 상품 구매하기

> **각 렌더링은 고유한 이팩트를 갖는다**  
> `useEffect`를 렌더링 아웃풋에 어떤 동작 하나를 "붙이는" 것으로 생각할 수 있다.
>
> ```tsx
> export default function ChatRoom({ roomId }) {
>   useEffect(() => {
>     const connection = createConnection(roomId);
>     connection.connect();
>     return () => connection.disconnect();
>   }, [roomId]);
>
>   return <h1>Welcome to {roomId}!</h1>;
> }
> ```
>
> 위 예시를 가지고 유저가 앱 이곳저곳을 네비게이션할 때 어떤 일이 일어나는지 확인해보자.
>
> **초기 렌더링**  
> 유저가 `<ChatRoom roomId="general" />`을 방문한다. 속으로 `roomId`를 `"general"`로 대체해보자:
>
> ```tsx
> // JSX for the first render (roomId = "general")
> return <h1>Welcome to general!</h1>;
> ```
>
> **이팩트 또한 렌더링 아웃풋의 한 부분이다.** 첫 번째 렌더링의 이팩트는 다음과 같다:
>
> ```tsx
> // Effect for the first render (roomId = "general")
> () => {
>   const connection = createConnection("general");
>   connection.connect();
>   return () => connection.disconnect();
> },
>   // Dependencies for the first render (roomId = "general")
>   ["general"];
> ```
>
> 리액트는 `"general"` 채팅방으로 연결하는 위 이팩트를 실행한다.
>
> **의존성이 동일한 경우의 리렌더링**  
> `<ChatRoom roomId="general" />` 컴포넌트가 리렌더링된다고 하면, JSX 아웃풋은 동일할 것이다:
>
> ```tsx
> // JSX for the second render (roomId = "general")
> return <h1>Welcome to general!</h1>;
> ```
>
> 리액트는 렌더링 아웃풋이 변화하지 않았음을 확인하여 DOM을 업데이트 하지 않는다.  
> 두 번째 렌더링에서의 이팩트는 다음과 같을 것이다:
>
> ```tsx
> () => {
>   const connection = createConnection("general");
>   connection.connect();
>   return () => connection.disconnect();
> },
>   // Dependencies for the second render (roomId = "general")
>   ["general"];
> ```
>
> 리액트는 두 번째 렌더링의 `["general"]`과 첫 번째 렌더링의 `["general"]`을 비교한다. **모든 의존성이 동일하므로, 리액트는 두 번째 렌더링에서의 이팩트를 _무시한다_.** 해당 이팩트는 호출되지 않는다.
>
> **의존성이 다른 경우의 리렌더링**  
> 그런 다음 유저는 `<ChatRoom roomId="travel" />`을 방문한다. 이때 컴포넌트는 다른 JSX를 반환한다:
>
> ```tsx
> // JSX for the third render (roomId = "travel")
> return <h1>Welcome to travel!</h1>;
> ```
>
> 리액트는 DOM을 업데이트하여 `"Welcome to general"`을 `"Welcome to travel"`로 변경한다.  
> 세 번째 렌더링의 이팩트는 아래와 같다:
>
> ```tsx
> // Effect for the third render (roomId = "travel")
> () => {
>   const connection = createConnection("travel");
>   connection.connect();
>   return () => connection.disconnect();
> },
>   // Dependencies for the third render (roomId = "travel")
>   ["travel"];
> ```
>
> 리액트는 세 번째 렌더링의 `["travel"]`을 두 번째 렌더링의 `["general"]`과 비교한다. 의존성 하나가 다르다, 즉 `Object.is("travel", "general")`이 false이다. 이팩트가 스킵되지 않는다.  
> **리액트가 세 번째 렌더링의 이팩트를 적용하기 전에, 이미 _실행되었던_ 이전 이팩트를 클린업해야 한다.** 두 번째 렌더링의 이팩트는 스킵되었으므로, 리액트는 첫 번째 렌더링의 이팩트를 클린업해야 한다. 이는 앱과 `"general"` 채팅방 사이의 연결을 끊을 것이다.  
> 이후, 리액트는 세 번째 렌더링의 이팩트를 실행한다. 이는 `"travel"` 채팅방으로의 연결을 수행한다.
>
> **언마운트**  
> 마침내 유저가 다른 곳으로 네비게이션하여 `<ChatRoom />` 컴포넌트가 언마운트한다고 해보자. 리액트는 마지막 이팩트의 클린업 함수를 실행한다. 마지막 이팩트는 세 번째 렌더링에 의한 것이다. 세 번째 렌더링의 클린업은 `createConnection("travel")`을 끊는다. 따라서 앱은 `"travel"` 채팅방과의 연결을 끊는다.

## 리액티브한 이팩트의 생명주기

이팩트는 컴포넌트와는 다른 생명주기를 갖는다. 컴포넌트가 마운트, 업데이트, 또는 언마운트 하는 것과 달리, 이팩트는 두 가지 일만을, 즉 무언가와의 동기화를 시작하거나, 후에 해당 동기화를 멈추는 일만을 수행한다. 그리고 이 같은 이팩트의 생명주기는 그 이팩트가 의존하는 props나 상태의 변화에 의해 여러 번 반복될 수 있다.

리액트는 린터 규칙을 제공하여 이팩트의 의존성이 올바르게 명시되었는지 확인토록 한다. 이는 이팩트가 최신 props 및 상태에 계속해서 동기화되도록 보장한다.

### 이팩트의 생명주기

모든 리액트 컴포넌트는 도일한 생명주기를 따른다:

- 컴포넌트는 화면에 추가될 때 **마운트**한다.
- 컴포넌트는 일반적인 경우 유저 인터랙션에 반응하여 새로운 props나 상태를 받아들일 때 **업데이트**한다.
- 컴포넌트는 화면에서 제거될 때 **언마운트**한다.

**이는 컴포넌트를 이해하는 좋은 그림을 제공하지만, 이팩트에 대해서는 그렇지 않다.** 즉 각 이팩트는 컴포넌트의 생명주기와는 독립적인 것으로 생각되어야 한다. 여기서 하나의 이팩트는 외부 시스템을 현재 props 및 상태에 동기화하는 방법을 묘사한다.

아래 이팩트는 컴포넌트를 채팅 서버에 연결한다:

```tsx
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

여기서 이팩트의 바디는 어떻게 **동기화를 시작하는지** 명시한다:

```tsx
const connection = createConnection(serverUrl, roomId);
connection.connect();
```

이팩트가 반환하는 클린업 함수는 어떻게 **동기화를 멈추는지** 명시한다:

```tsx
connection.disconnect();
```

직관적으로 보자면 리액트가 컴포넌트의 마운트 시에 **동기화를 시작**하고 컴포넌트 언마운트 시에 **동기화를 중단**할 것으로 생각할 수 있다. 하지만 컴포넌트가 동일한 상태를 가지고 **동기화를 여러 번 시작하고 멈추고** 할 필요가 있는 경우가 있을 수 있다.

이제 **왜** 이러한 일이 필요하고, **언제** 일어나며, **어떻게** 이러한 동작을 제어할 수 있는지 살펴보자.

### 왜 동기화가 두 번 이상 일어날 필요가 있을 수 있는가?

`<ChatRoom />` 컴포넌트가 유저가 드롭다운에서 선택한 `roomId` prop을 전달받는다고 해보자. 초기에 유저가 `"general"`을 `roomId`로 선택하면, 앱은 `"general"`인 채팅방을 보여준다:

```tsx
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

UI가 노출된 후 리액트는 이팩트를 실행하여 동기화를 시작한다. 이팩트는 `"general"` 채팅방에 연결한다:

```tsx
function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // "general" 방에 연결한다
    connection.connect();
    return () => {
      connection.disconnect(); // "general" 방과의 연결을 끊는다
    };
  }, [roomId]);
  // ...
}
```

이후에 유저가 드롭다운에서 다른 방, 가령 `"travel"`을 선택한다고 해보자. 우선 리액트는 UI를 업데이트할 것이다:

```tsx
function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

유저는 UI에서 선택된 채팅방이 `"travel"`임을 보게 된다. 하지만 이전에 실행된 이팩트는 여전히 `"general"` 방에 연결되어 있다. **`roomId` prop이 변경되었으므로 이팩트가 수행했던 것(`"general"` 방과의 연결)은 더 이상 UI와 일치하지 않는다.**

이때 리액트는 두 가지를 수행해야 한다:

1. 이전 `roomId`와의 동기화를 중단 (`"general"` 방과의 연결 해제)
2. 새로운 `roomId`와의 동기화를 시작 (`"travel"` 방에 연결)

**다행히 리액트는 사전에 위 두 가지를 어떻게 수행할 것인지 알고 있다.** 이팩트의 바디는 어떻게 동기화를 시작하는지 명시하고 있고, 클린업 함수는 어떻게 동기화를 중단하는지 명시하고 있기 때문이다. 이제 리액트가 해야 할 일은 이들을 올바른 순서로, 올바른 props 및 상태를 이용하여 호출하는 것 뿐이다. 이제 이 일이 정확히 어떻게 일어나는지 살펴보자.

### 어떻게 리액트는 이팩트를 재동기화하는가?

`<ChatRoom />` 컴포넌트는 새로운 값의 `roomId` prop을 받았다. 리액트는 이팩트를 재동기화하여 새로운 방으로 재연결해야 한다.

**동기화를 중단**하기 위해 리액트는 이팩트가 `"general"` 방으로의 연결 후에 반환하는 클린업 함수를 호출할 것이다. `roomId`가 `"general"`이었으므로 클린업 함수는 `"general"` 방과의 연결을 끊을 것이다.

그러면 리액트는 해당 렌더링 중에 제공된 이팩트를 실행할 것이다. 이때 `roomId`는 `"travel"`이므로 `"travel"` 채팅방으로의 **동기화가 시작**될 것이다.

이 덕분에 이제 유저가 UI에서 선택한 것과 동일한 방으로의 연결이 이루어진다.

컴포넌트가 다른 `roomId`로 렌더링되는 때마다 이팩트는 매번 재동기화를 수행할 것이다. 가령 유저가 `roomId`를 `"travel"`에서 `"music"`으로 변경한다고 하면, 리액트는 클린업 함수를 호출함으로써 다시 이팩트의 **동기화를 중단**할 것이다. 그런 후 이팩트의 바디를 새로운 `roomId` prop과 함께 실행하여 다시 **동기화를 시작**할 것이다.

마침내 유저가 다른 화면으로 이동하면, `<ChatRoom />`은 언마운트한다. 이제 연결을 유지할 필요가 전혀 없다. 리액트는 마지막으로 이팩트의 **동기화를 중단**하고 `"music"` 채팅방으로의 연결을 해제할 것이다.

### 이팩트의 관점에서 생각하기

```tsx
useEffect(() => {
  // roomId로 명시된 방으로 연결된 이팩트
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => {
    // 연결이 해제될 때까지만!
    connection.disconnect();
  };
}, [roomId]);
```

위 코드 구조는 어떤 사건들이 서로 겹치지 않으면서 연속되어 일어나는 이팩트의 모습을 보는 데 도움을 준다:

1. 이팩트는 `"general"` 방으로 연결한다. (연결 해제 시까지)
2. 이팩트는 `"travel"` 방으로 연결한다. (연결 해제 시까지)
3. 이팩트는 `"music"` 방으로 연결한다. (연결 해제 시까지)

이전에는 컴포넌트의 관점에서 생각하여 이팩트를 "렌더링 이후" 또는 "언마운트 이전"과 같은 특정한 시점에 발동되는 "콜백" 또는 "생명주기 이벤트" 정도로 생각했을 수 있다.

**그러나 사실은, 한 시점에서의 단일한 시작/중단의 주기(a single start/stop cycle at a time)라는 관점에 항상 집중해야 한다. 컴포넌트가 마운트, 업데이트, 언마운트하는지 여부는 중요하지 않다. 오히려 해야 할 일은 어떻게 동기화를 시작하고 중단하는가를 묘사하는 것 뿐이다. 이를 잘 수행한다면 이팩트는 필요한 한 여러 번 시작되고 중단되는 데 있어 탄력성을 갖게 될 것이다.**

### 각 이팩트는 하나의 분리된 동기화 프로세스를 나타낸다

어떤 로직이 이미 작성한 이팩트와 동일한 시점에 실행되어야 한다는 이유만으로 이팩트에 관련성 없는 로직을 추가하는 일은 삼가야 한다. 가령 유저가 채팅방에 방문할 때 애널리틱스를 보내고자 한다고 해보자. `roomId`에 의존하는 이팩트가 이미 있으므로, 그 자리에 애널리틱스 호출을 추가하고 싶을 수 있다:

```tsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId); // *
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

그러나 추후에 연결을 재설정할 필요성에 의해 해당 이팩트에 또 다른 의존성을 추가한다고 생각해보자. 이팩트가 재동기화한다면, 동일한 채팅방에 대한 `logVisit(roomId)` 또한 호출될 것인데, 이는 의도한 바와는 다르다. 방문 로그를 쌓는 일은 연결과는 **분리된 하나의 프로세스**이다. 그러므로 이들을 두 개의 분리된 이팩트로 작성해야 한다:

```tsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}
```

**각 이팩트는 분리되고 독립적인 동기화 프로세스를 표현해야 한다.**

위의 예시에서 하나의 이팩트를 제거하는 것은 다른 이팩트의 로직을 깨뜨리지 않을 것이다. 이는 해당 이팩트들이 서로 다른 것들을 동기화한다는 점을 암시하므로, 그들을 분리하는 것은 타당한 전략으로 보인다. 다른 한편, 어떤 로직의 결합력 있는 일부분을 다른 이팩트로 분리한다면, 코드는 "더 깨끗하게" 보일 수 있겠으나 유지보수하기는 더 어려워질 것이다. 그렇기에 코드가 더 깨끗하게 보이는지 여부가 아니라, 프로세스가 동일한지 분리되어 있는지 여부에 초점을 맞추어 생각해야 한다.

### 이팩트는 리액티브한 값들에 "반응한다"(react to)

아래 이팩트는 두 개의 변수, 즉 `serverUrl`과 `roomId`를 읽고 있지만, `roomId`만이 의존성으로 명시되어 있다:

```tsx
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
```

`serverUrl`이 의존성에 추가될 필요가 없는 이유는 그것이 리렌더링에 의해서는 결코 변화하지 않기 때문이다. `serverUrl`은 컴포넌트가 얼마나 많이, 어떤 이유로 리렌더링되었는가와는 상관 없이 항상 동일하다. `serverUrl`이 결코 변하지 않으므로 이를 의존성으로 명시하는 것은 타당하지 않다. 결과적으로 의존성은 그들이 시간에 따라 변화하는 경우에만 어떤 일을 수행한다!

다른 한편 `roomId`는 리렌더링 시에 값이 다를 수 있다. **컴포넌트 안에서 선언된 props나 상태 혹은 다른 값들은 *리액티브*하다 왜냐하면 그것들은 렌더링 중에 계산되며 리액트의 데이터 흐름에 참여하기 때문이다.**

만약 `serverUrl`이 상태 변수라면 리액티브할 수 있다. 리액티브한 값들은 반드시 의존성에 포함되어야 한다:

```tsx
function ChatRoom({ roomId }) {
  // props는 시간에 따라 변화한다
  const [serverUrl, setServerUrl] = useState("https://localhost:1234"); // 상태는 시간에 따라 변할 수 있다

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // 이 이팩트는 props와 상태를 읽는다
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // 따라서 이 이팩트는 props와 상태에 “의존한다”고 리액트에게 알려준다
  // ...
}
```

`serverUrl`을 의존성에 포함시킴으로써 이팩트가 `serverUrl`의 변화 이후에 재동기화할 것임을 보장한다.

### 빈 의존성 배열을 갖는 이팩트는 무엇을 의미하는가?

컴포넌트의 관점에서 생각해보자면, 공백의 `[]` 의존성 배열은 해당 이팩트가 컴포넌트 마운트 시에만 채팅방에 연결하며, 컴포넌트 언마운트 시에만 연결을 해제함을 의미한다.

그러나 이팩트의 관점에서 생각해보자면, 마운트나 언마운트에 대해 전혀 생각할 필요가 없다. 중요한 것은 동기화를 시작하고 중단하기 위해 이팩트가 무엇을 해야 하는지 명시해놓았다는 점이다.

### 컴포넌트 바디 안에서 선언된 변수들은 모두 리액티브하다
