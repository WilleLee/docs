# bc challenge DAY 2 학습 정리

## 리눅스 / 유닉스

유닉스(Unix)는 1960년대, AT&T 벨 연구소에 의해 개발된 멀티유저, 멀티태스킹 운영체제로, 리눅스를 포함한 대부분의 운영체제가 유닉스의 영향을 받은 유닉스 계열의 운영체제이다.

한편 리눅스(Linux)는 리누스 토리발스가 1991년에 개발한 유닉스 계열 오픈소스 운영체제이다. 따라서 누구든 리눅스를 사용하고 개발 및 기여할 수 있다.

## SSH

SSH(Secure Shell)는 원격의 쉘에 접속하기 위한 네트워크 프로토콜로, 기존의 텔넷(텍스트 기반 통신)에 키 교환 알고리듬 기반 암호화를 추가한 것이다.

SSH 서버를 구성하기 위해 다양한 패키지가 사용될 수 있는데, 이 중 `OpenSSH`가 가장 널리 사용된다. 기본 포트는 22번이다.

### ubuntu에서 ssh 설정

`openssh-server` 패키지를 설치

```bash
$ sudo apt install openssh-server
```

`ssh` 실행 상태 확인

```bash
$ sudo systemctl status ssh
```

방화벽 확인 및 설정

```bash
$ sudo ufw status
$ sudo ufw allow ssh
$ sudo ufw reload
```

### 클라이언트 로컬 컴퓨터에서 원격 접속

```bash
$ ssh <계정명>@<서버 IP 주소>
```

## ubuntu에서 계정 생성 및 비밀번호 설정

계정 생성

```bash
$ adduser <계정명>
```

비밀번호 설정

```bash
$ passwd <계정명>
```

## [디렉터리 접근 권한](https://inpa.tistory.com/entry/LINUX-%F0%9F%93%9A-%ED%8C%8C%EC%9D%BC-%EA%B6%8C%ED%95%9C-%EC%86%8C%EC%9C%A0%EA%B6%8C%ED%97%88%EA%B0%80%EA%B6%8C-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)

리눅스는 여러 사람이 사용할 수 있는 멀티유저 운영체제이기 때문에, 자료 접근에 있어서 보안상의 문제가 발생할 수 있다. 이러한 문제를 해결하기 위해 리눅스에는 *권한*이라는 개념이 존재한다. 권한은 사용자, 그룹, 기타 사용자에 대해 읽기, 쓰기, 실행의 권한을 설정할 수 있다.

### 파일 권한 정보 확인

```bash
$ ls -l
```

### 허가권

읽거나 쓰거나 실행할 권리를 `사용자 / 그룹 / 기타 사용자`로 나누어 설정할 수 있다. `r`, `w`, `x`는 각각 읽기, 쓰기, 실행 권한을 의미한다.

### 허가권의 변경

```bash
$ chmod 764 <파일명>
```

`r`, `w`, `x` 순으로 숫자로 표현하며, 각 숫자는 아래와 같은 의미를 가진다.

| 8진수 | 2진수 | 권한 | 의미                 |
| ----- | ----- | ---- | -------------------- |
| 0     | 000   | ---  | 아무 권한 없음       |
| 1     | 001   | --x  | 실행 권한만 있음     |
| 2     | 010   | -w-  | 쓰기 권한만 있음     |
| 3     | 011   | -wx  | 쓰기, 실행 권한 있음 |
| 4     | 100   | r--  | 읽기 권한만 있음     |
| 5     | 101   | r-x  | 읽기, 실행 권한 있음 |
| 6     | 110   | rw-  | 읽기, 쓰기 권한 있음 |
| 7     | 111   | rwx  | 모든 권한 있음       |

곧 `764`란, 사용자는 `rwx`, 그룹은 `rw-`, 기타 사용자는 `r--` 권한을 가진다는 의미이다.

## 쉘 스크립트

쉘 스크립트는 유닉스 기반 운영체제의 쉘을 실행하기 위한 명령어들을 갖는 텍스트 파일이다. 쉘 스크립트는 작업들을 자동화하여 복잡한 작업을 간단히 수행할 수 있도록 한다.

## [`crontab`](https://jdm.kr/blog/2)

`crontab`은 리눅스에서 주기적으로 작업을 실행하기 위한 스케줄러이다. 즉 특정 시간에 특정 작업을 실행할 수 있도록 한다.

### `crontab` 명령어

- `crontab -e` : `crontab` 파일을 편집한다.
- `crontab -l` : `crontab` 파일의 내용을 출력한다.
- `crontab -r` : `crontab` 파일을 삭제한다.

### `crontab` 파일 형식

`crontab` 파일은 아래와 같은 형식을 가진다.

```bash
$ * * * * * <command>
```

- 위에서 `*`은 왼쪽부터 각각 `분(0 ~ 59)`, `시(0 ~ 23)`, `일(1 ~ 31)`, `월(1 ~ 12)`, `요일(0 ~ 7)`을 의미하며, 요일에서 `0`과 `7`은 일요일을 의미하고, `1` ~ `6`은 월요일부터 토요일을 의미한다.
- `<command>`는 실행할 명령어를 의미한다.

따라서 아래 명령어들은 각각 아래의 의미를 가진다.

```bash
$ * * * * * home/scripts/test.sh
# 매 분마다 /home/scripts/test.sh 실행
$ 45 5 * * 5 /home/script/test.sh
# 매주 금요일 오전 5시 45분에 /home/script/test.sh 실행
```

## CPU 사용률, 메모리 사용률, 네트워크 인터페이스 RX/TX 사용량 조회

### CPU 사용률

#### `top` 명령어

```bash
$ top
```

`top` 명령어는 리눅스에서 CPU 사용률, 메모리 사용률, 프로세스 정보 등을 확인할 수 있는 명령어이다. `top`의 옵션 가운데 `-b`는 순간의 정보를 출력하도록 하고, `-n`은 반복 횟수를 지정한다. 따라서,

```bash
$ top -b -n 1
```

위 명령어를 통해 한 번의 정보를 출력할 수 있다.

#### `grep` 명령어

`grep` 명령어는 전달된 파일 내용 중 특정 문자열을 찾는 데 사용된다. 가령,

```bash
$ top -b -n 1 | grep "Cpu(s)"
```

위 명령어는 `top` 명령어의 결과 중 `Cpu(s)` 문자열을 포함하는 줄을 출력한다.

#### `awk` 명령어

`awk` 명령어는 텍스트 파일을 읽어서 특정 패턴을 찾거나 변환하는 데 사용된다. 가령,

```bash
$ sum=$(echo cpu_line | awk -F':,%' '{print $2 + $4 + $6 + $8 + $10 + $12 + $14 + $16}')
```

위 명령어는 `cpu_line` 문자열에서 `:`와 `,`를 구분자로 하여 2, 4, 6, 8, 10, 12, 14, 16번째 필드를 더한 값을 `sum`에 저장한다. 곧 `sum`은 CPU 사용률을 의미한다.

### 메모리 사용률

```bash
$ free -m | grep "Mem"
```

위 명령을 통해 메모리 사용량을 보여주는 줄을 출력할 수 있다.

```bash
$ total_mem=$(echo mem_line | awk '{print $2}')
$ used_mem=$(echo mem_line | awk '{print $3}')
```

그러면 위와 같이 총 메모리량과 사용된 메모리량을 구할 수 있다. 따라서,

```bash
$ mem_rate=$(echo "scale=2; $used_mem / $total_mem * 100" | bc)
```

위 명령어를 통해 메모리 사용률을 구할 수 있다.

### 네트워크 인터페이스 RX/TX 사용률

`ifconfg` 명령어를 통해 네트워크 인터페이스의 RX, TX 사용량을 확인할 수 있다. `ifconfig`를 사용하기 위해서는 우선 `net-tools` 패키지를 설치해야 한다.

```bash
$ sudo apt install net-tools
```

이후,

```bash
$ ifconfig
```

명령어를 통해 네트워크 인터페이스 정보를 확인할 수 있다.

## CPU, 메모리 사용률 강제로 높이기
