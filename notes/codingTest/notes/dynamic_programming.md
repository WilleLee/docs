# 다이나믹 프로그래밍(dynamic programming) = 동적 계획법

> 일반적으로 프로그래밍에서 '동적'이라는 것은 '프로그램이 실행되는 도중'이라는 의미이다. 예를 들어 자료구조에서 동적 할당(dynamic allocation)은 프로그램이 실행되는 도중에 메모리를 할당하는 것을 의미한다. 하지만 다이나믹 프로그래밍에서의 '다이나믹'은 그런 의미가 아니다.

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다. 피보나치 수열은 다음과 같은 점화식으로 정의된다.

_a_<sub>1</sub> = 1, _a_<sub>2</sub> = 1, _a_<sub>n</sub> = _a_<sub>n-1</sub> + _a_<sub>n-2</sub>

그렇다면 이를 통해 실제로 피부나치 수를 구하는 과정은 어떨까? n번째 피보나치 수를 f(n)이라 하면, f(4)를 구하려면 f 함수를 반복해서 호출해야 한다. 이때 f(2), f(1)은 항상 1이므로 f(1)이나 f(2)를 만나면 호출을 정지한다.

```typescript
function fibo(x: number) {
  if (x === 1 || x === 2) {
    return 1;
  }
  return fibo(x - 1) + fibo(x - 2);
}
// fibo(4) = fibo(3) + fibo(2) = (fibo(1) + fibo(2)) + 1 = 2 + 1 = 3
```

하지만 피보나치 수열의 코드를 이렇게 작성하면 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다(O(2<sup>_n_</sup>)).

## 다이나믹 프로그래밍의 조건

- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

## 메모이제이션 = 캐싱

- 다이나믹 프로그래밍을 구현하는 방법 중 하나
- 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 어떻게 구현? 한 번 구한 정보를 리스트에 저장

```typescript
const d = Array(100).fill(0);

function fibo(x: number) {
  if (x === 1 || x === 2) {
    return 1;
  }
  if (d[x] !== 0) {
    return x;
  }
  d[x] = fibo(x - 1) + fibo(x - 2);
  return d[x];
}

console.log(fibo(99));
```

## 다이나믹 프로그래밍 vs 분할 정복(divide and conquer)

다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘이다.

큰 문제를 작게 나누는 방법은 퀵 정렬의 분할 정복 알고리즘과 유사하다. 다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍에서는 문제들이 서로 영향을 미친다는 점이다.

다이나믹 프로그래밍에서 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 오버헤드가 발생할 수 있다. 따라서 재귀 함수 대신 반복문을 사용하여 오버헤드를 줄일 수 있다.

재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 top-down 방식(큰 문제를 해결하기 위해 작은 문제를 호출)이라 한다. 반면에 반복문을 이용하여 소스코드를 작성하는 경우를 bottom-up 방식(작은 문제부터 답을 도출)이라 한다.

```typescript
const d = Array(100).fill(0);

d[1] = 1;
d[2] = 1;
const n = 99;

for (let i = 3; i <= n; i++) {
  d[i] = d[i - 1] + d[i - 2];
}

console.log(d[n]); // 218922995834555200000
```
