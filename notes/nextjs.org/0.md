# 라우팅

## 라우팅 펀더멘탈

모든 어플리케이션의 골자는 라우팅이다.

#### 주요 개념들

- 트리 : 계층적 구조를 시각화하기 위한 하나의 약속.
- 서브트리 : 새로운 루트에서 시작하여 리프에서 끝나는, 트리의 일부분.
- 루트 : 트리 또는 서브트리의 첫 번째 노드. e.g. root layout
- 리프 : 자식을 갖지 않는 서브트리의 노드들.
- URL 세그먼트 : /로 구분된 URL의 일부분.
- URL 경로 : URL 세그먼트들의 합.

#### 앱 라우터

넥스트 버전 13에서 소개된 앱 라우터는 리액트 서버 컴포넌트를 기반으로 하며, 레이아웃의 공유, 네스티드 라우팅, 로딩 상태, 에러 핸들링 등을 지원한다.  
앱 라우터는 app 디렉터리 안에서 작동한다. app 디렉터리 내의 컴포넌트들은 모두 기본적으로 리액트 서버 컴포넌트이므로, 퍼포먼스 최적화, 서버 컴포넌트 사용성 등에서 이점을 가진다.

#### 폴더와 파일의 역할

넥스트는 파일 시스템에 기반한 라우터를 이용한다.

- **폴더들**은 라우트를 정의하는 데 이용된다. 하나의 라우트는 네스팅된 폴더들 사이 하나의 경로이며, 루트 폴더에서 시작하여 page.js 파일을 갖는 마지막 리프 폴더까지 이어지는 파일 시스템 계층 구조를 따른다.
- **파일들**은 각 라우트 세그먼트에서 보여지는 UI를 생성하는 데 이용된다.

#### 라우트 세그먼트

하나의 라우트 내의 각 폴더는 하나의 라우트 세그먼트를 나타낸다. 각 라우트 세그먼트는 URL 경로 상에서 일치하는 세그먼트와 연결된다.

![route segments](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Froute-segments-to-path-segments.png&w=3840&q=75&dpl=dpl_DyNfXwC3D1n6XsQpQvXsQ3g8fPYu)

#### 네스티드 라우트

폴더를 다른 폴더로 감싸면 하나의 네스티드 라우트가 생성된다. 가령 /dashboard/settings라는 라우트를 추가하려면 app 디렉터리에 dashboard 폴더를 생성하고, 그 안에 settings 폴더를 생성하면 된다.

#### 파일 컨벤션

넥스트는 특별한 파일 이름 컨벤션을 제공하며, 이를 통해 특정 동작을 수행하는 UI를 생성할 수 있다.

- layout.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 UI를 생성한다.
- page.js : 하나의 라우트 세그먼트에 대하여 유니크한 UI를 생성하여 해당 라우트가 외부에서 접근 가능하도록 한다.
- loading.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 로딩 UI를 생성한다.
- not-found.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 404 UI를 생성한다.
- global-error.js : 전역 에러 핸들링을 위한 UI를 생성한다.
- route.js : 서버 사이드 API 엔드포인트를 생성한다.
- template.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 UI를 생성하는데, 리렌더링되는 UI에 특화된다.
- default.js : 평행 라우트를 위한 fallback UI를 생성한다.

#### 컴포넌트 계층

하나의 라우트 세그먼트에서 위 파일 컨벤션에 따라 정의된 특별한 컴포넌트들은 특정 계층에서 렌더링된다.

![component hierarchy](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Ffile-conventions-component-hierarchy.png&w=3840&q=75&dpl=dpl_DyNfXwC3D1n6XsQpQvXsQ3g8fPYu)

하나의 네스티드 라우트에서 한 라우트 세그먼트의 컴포넌트들은그 부모 세그먼트의 컴포넌트들 안에 네스팅된다.

#### 동일 장소 배치

특별 파일들에 더불어, components, styles, tests 등 같은 커스텀 파일들 또한 app 디렉터리 내 폴더 안에서 동일 장소 배치될 수 있다. 이는 각 폴더가 라우트 세그먼트를 정의하기는 하지만, page.js, route.js 파일을 갖는 폴더만이 외부에서 접근 가능한 주소로 인식되기 때문이다.

#### 고급 라우팅 패턴

앱 라우터는 보다 진전된 라우팅 패턴들을 지원하기 위한 컨벤션들도 제공한다.

- 평행 라우트 : 동일 뷰에 대하여 둘 이상의 페이지들을 동시에 보여준다.
- 간섭 라우트 : ???

## 라우트 정의하기

#### 라우트 생성

넥스트는 폴더 계층 구조를 이용해 라우트를 정의하는 파일 시스템 기반 라우터를 이용한다.  
app 디렉터리의 각 폴더는 하나의 URL 세그먼트를 표시하는 하나의 라우트 세그먼트를 표현하다. 폴더를 다른 폴더로 네스팅하면 하나의 네스티드 라우트가 생성된다. 이때 page.js 파일을 갖는 라우트 세그먼트는 외부에서 접근 가능한 주소로 인식된다.

#### UI 생성

특별한 파일 컨벤션을 이용해 각 라우트 세그먼트에 대한 UI를 생성할 수 있다. 가장 일반적인 형태는 page.js 파일들로 각 라우트의 특정한 UI를 보여주고, layout.js 파일들로 여러 라우트에서 공유되는 UI를 보여주는 것이다.

## 페이지와 레이아웃

### 페이지

하나의 페이지는 하나의 라우트 세그먼트에 대하여 유니크한 UI이다. page.js 파일에서 리액트 컴포넌트를 default export하여 페이지를 정의할 수 있다. 네스티드 폴더로 라우트 세그먼트를 정의하고, page.js 파일로 해당 라우트에 접근 가능하도록 하는 것이다.

### 레이아웃

레이아웃은 여러 페이지에서 공유되는 UI이다. 네비게이션이 일어나는 중에도 레이아웃은 **상태를 유지**하고, 상호작용을 중단하지 않으며, 리렌더링되지 않는다. 그리고 레이아웃들 또한 네스팅될 수 있다.

레이아웃은 layout.js 파일에서 리액트 컴포넌트를 default export하여 정의할 수 있다. 레이아웃 컴포넌트는 children prop을 받아서 렌더링 중에 자식 레이아웃 및 자식 페이지에 populate한다.

> populate (programming) : 데이터를 특정 구조에 채워넣다. e.g. you can populate a react state with data from an API call.

> **good to know**
>
> - 최상단의 레이아웃은 root layout이라 불린다. root layout은 required이며, 앱 내 모든 페이지에서 공유된다.
> - 모든 라우트 세그먼트에서 고유의 레이아웃을 선택적으로 정의할 수 있다. 이 레이아웃은 해당 라우트 세그먼트에 네스팅되는 모든 페이지에 공유된다.
> - 레이아웃들은 기본적으로 네스팅된다. 각각의 부모 레이아웃은 children prop을 이용해 자식 레이아웃을 감싼다.
> - 레이아웃은 기본적으로 서버 컴포넌트이며, 클라이언트 컴포넌트로 설정할 수도 있다.
> - 레이아웃에서도 데이터를 패치할 수 있다.
> - 부모 레이아웃과 자식 간에 데이터를 전달할 수는 없다. 그러나 어떤 라우트에서 동일한 데이터를 여러 번 패치할 때, 리액트는 퍼포먼스에 영향을 주지 않으면서 자동적으로 중복된 API 리퀘스트를 제거한다. 이는 React가 내부적으로 데이터 요청을 추적하고, 동일한 요청이 여러 번 발생하면 한 번만 실제로 요청을 보내고 그 결과를 여러 곳에서 재사용하기 때문이다.
> - 레이아웃은 하위의 라우트 세그먼트에 접근할 수 없다. 모든 라우트 세그먼트에 접근하기 위해서는 useSelectedLayoutSegment 또는 useSelectedLayoutSegments를 이용해야 한다.
> - 레이아웃 생성에 .js, .jsx, .tsx 파일 확장자를 사용할 수 있다.
> - 하나의 폴더에서 각각 하나의 layout.js와 page.js가 정의될 수 있다. 여기서 레이아웃이 페이지를 감싼다.

### 루트 레이아웃 (Required)

루트 레이아웃은 앱 디렉터리 최상단에서 정의되며, 모든 라우트 세그먼트에 적용된다. 루트 레이아웃을 이용하면 서버에서 반환되는 초기 HTML을 변형할 수 있다.

> **good to know**
>
> - 앱 디렉터리는 반드시 하나의 루트 레이아웃을 가져야 한다.
> - 루트 레이아웃은 반드시 `<html>`, `<body>` 태그를 정의해야 한다. 넥스트가 그것들을 자동으로 생성하지 않기 때문이다.
>   `<title>`과 같은 `<head>` 요소들은 빌트인 SEO 지원을 통해 관리할 수 있다.
> - 라우트 그룹을 이용해 다수의 루트 레이아웃을 생성할 수도 있다.
> - 루트 레이아웃은 기본적으로 서버 컴포넌트이며, 클라이언트 컴포넌트로 설정할 수는 **없다**.

### 레이아웃의 네스팅

어떤 폴터 안에서 레이아웃(e.g. `app/dashboard/layout.js`)이 정의되면, 그것은 특정 라우트 세그먼트(e.g. `example.com/dashboard`)에 적용되며, 해당 라우트 세그먼트가 액티브할 때 레이이웃은 렌더링된다. 기본적으로 서로 연결되는 파일 계층 내의 레이아웃들은 서로 네스팅되는데, 이는 각 레이아웃이 children prop을 이용해 자식 레이아웃을 감싸는 것을 의미한다.

> **good to know**
>
> - 오직 루트 레이아웃에서만 `<html>`, `<body>` 태그들이 정의될 수 있다.

### 템플릿

템플릿은 자식 레이아웃 또는 자식 페이지를 네스팅한다는 점에서 레이아웃과 유사하다. 그러나 레이아웃이 여러 라우트 세그먼트들에 걸쳐서 보존되고 상태를 유지하는 것과 달리, 템플릿은 네비게이션 중에 자식 컴포넌트들에 대한 새로운 인스턴스를 생성한다. 이는 하나의 템플릿을 공유하는 라우트 간에서 유저가 이동할 때에도 해당 컴포넌트의 새로운 인스턴스가 마운트되고, DOM 요소들은 재생성되며, 상태들은 보존되지 않고, 이팩트는 재동기화된다는 것을 의미한다.

아래 상황들에서 템플릿은 레이아웃보다 강점을 가질 수 있다.

- useEffect, useState에 의지하는 특징을 갖는 경우.
- 프레임워크의 디폴트 동작을 변화시킬 필요가 있는 경우. e.g. 레이아웃의 서스펜스 바운더리는 레이아웃이 로드되는 단 한 번의 순간에만 fallback을 노출시키고, 페이지 이동 시에는 보여주지 않는 반면, 템플릿에서는 네비게이션이 이루어질 때마다 해당 fallback을 노출시킨다.

템플릿은 template.js 파일에서 리액트 컴포넌트를 default export하여 정의할 수 있는데, 이 컴포넌트는 하나의 children prop을 받아야 한다. 네스팅의 관점에서 보자면 템플릿은 레이아웃과 children 사이에서 렌더링된다.

```javascript
<Layout>
  {/* Note that the template is given a unique key. */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

### `<head>`의 수정

앱 디렉터리에서는 빌트인 SEO 지원을 이용해 `<title>`, `<meta>` 같은 `<head>` 요소들을 수정할 수 있다. 메타데이터는 layout.js 또는 page.js 파일에서 metadata 객체 또는 generateMetadata 함수를 export 함으로써 정의할 수 있다.

```javascript
// page.ts
import { Metadata } from “next”;

export const metadata: Metadata = {
  title: “Next.js”,
};

export default function Page() {
  return <></>;
}
```

> **good to know**
>
> - `<head>` 태그를 루트 레이아웃에 수동으로 추가해서는 **안 되며**, `<head>` 요소들의 스트리밍 또는 중복 제거와 같은 향상된 기능들을 자동으로 다루는 metadata API를 이용해야 한다.

## 링크와 네비게이션
