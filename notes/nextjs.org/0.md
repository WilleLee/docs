# 라우팅

## 라우팅 펀더멘탈

모든 어플리케이션의 골자는 라우팅이다.

#### 주요 개념들

- 트리 : 계층적 구조를 시각화하기 위한 하나의 약속.
- 서브트리 : 새로운 루트에서 시작하여 리프에서 끝나는, 트리의 일부분.
- 루트 : 트리 또는 서브트리의 첫 번째 노드. e.g. root layout
- 리프 : 자식을 갖지 않는 서브트리의 노드들.
- URL 세그먼트 : /로 구분된 URL의 일부분.
- URL 경로 : URL 세그먼트들의 합.

#### 앱 라우터

넥스트 버전 13에서 소개된 앱 라우터는 리액트 서버 컴포넌트를 기반으로 하며, 레이아웃의 공유, 네스티드 라우팅, 로딩 상태, 에러 핸들링 등을 지원한다.  
앱 라우터는 app 디렉터리 안에서 작동한다. app 디렉터리 내의 컴포넌트들은 모두 기본적으로 리액트 서버 컴포넌트이므로, 퍼포먼스 최적화, 서버 컴포넌트 사용성 등에서 이점을 가진다.

#### 폴더와 파일의 역할

넥스트는 파일 시스템에 기반한 라우터를 이용한다.

- **폴더들**은 라우트를 정의하는 데 이용된다. 하나의 라우트는 네스팅된 폴더들 사이 하나의 경로이며, 루트 폴더에서 시작하여 page.js 파일을 갖는 마지막 리프 폴더까지 이어지는 파일 시스템 계층 구조를 따른다.
- **파일들**은 각 라우트 세그먼트에서 보여지는 UI를 생성하는 데 이용된다.

#### 라우트 세그먼트

하나의 라우트 내의 각 폴더는 하나의 라우트 세그먼트를 나타낸다. 각 라우트 세그먼트는 URL 경로 상에서 일치하는 세그먼트와 연결된다.

![route segments](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Froute-segments-to-path-segments.png&w=3840&q=75&dpl=dpl_DyNfXwC3D1n6XsQpQvXsQ3g8fPYu)

#### 네스티드 라우트

폴더를 다른 폴더로 감싸면 하나의 네스티드 라우트가 생성된다. 가령 /dashboard/settings라는 라우트를 추가하려면 app 디렉터리에 dashboard 폴더를 생성하고, 그 안에 settings 폴더를 생성하면 된다.

#### 파일 컨벤션

넥스트는 특별한 파일 이름 컨벤션을 제공하며, 이를 통해 특정 동작을 수행하는 UI를 생성할 수 있다.

- layout.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 UI를 생성한다.
- page.js : 하나의 라우트 세그먼트에 대하여 유니크한 UI를 생성하여 해당 라우트가 외부에서 접근 가능하도록 한다.
- loading.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 로딩 UI를 생성한다.
- not-found.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 404 UI를 생성한다.
- global-error.js : 전역 에러 핸들링을 위한 UI를 생성한다.
- route.js : 서버 사이드 API 엔드포인트를 생성한다.
- template.js : 하나의 세그먼트와 그 자식 세그먼트들이 공유하는 UI를 생성하는데, 리렌더링되는 UI에 특화된다.
- default.js : 평행 라우트를 위한 fallback UI를 생성한다.

#### 컴포넌트 계층

하나의 라우트 세그먼트에서 위 파일 컨벤션에 따라 정의된 특별한 컴포넌트들은 특정 계층에서 렌더링된다.

![component hierarchy](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Ffile-conventions-component-hierarchy.png&w=3840&q=75&dpl=dpl_DyNfXwC3D1n6XsQpQvXsQ3g8fPYu)

하나의 네스티드 라우트에서 한 라우트 세그먼트의 컴포넌트들은그 부모 세그먼트의 컴포넌트들 안에 네스팅된다.

#### 동일 장소 배치

특별 파일들에 더불어, components, styles, tests 등 같은 커스텀 파일들 또한 app 디렉터리 내 폴더 안에서 동일 장소 배치될 수 있다. 이는 각 폴더가 라우트 세그먼트를 정의하기는 하지만, page.js, route.js 파일을 갖는 폴더만이 외부에서 접근 가능한 주소로 인식되기 때문이다.

#### 고급 라우팅 패턴

앱 라우터는 보다 진전된 라우팅 패턴들을 지원하기 위한 컨벤션들도 제공한다.

- 평행 라우트 : 동일 뷰에 대하여 둘 이상의 페이지들을 동시에 보여준다.
- 간섭 라우트 : ???

## 라우트 정의하기

#### 라우트 생성

넥스트는 폴더 계층 구조를 이용해 라우트를 정의하는 파일 시스템 기반 라우터를 이용한다.  
app 디렉터리의 각 폴더는 하나의 URL 세그먼트를 표시하는 하나의 라우트 세그먼트를 표현하다. 폴더를 다른 폴더로 네스팅하면 하나의 네스티드 라우트가 생성된다. 이때 page.js 파일을 갖는 라우트 세그먼트는 외부에서 접근 가능한 주소로 인식된다.

#### UI 생성

특별한 파일 컨벤션을 이용해 각 라우트 세그먼트에 대한 UI를 생성할 수 있다. 가장 일반적인 형태는 page.js 파일들로 각 라우트의 특정한 UI를 보여주고, layout.js 파일들로 여러 라우트에서 공유되는 UI를 보여주는 것이다.

## 페이지와 레이아웃

### 페이지

하나의 페이지는 하나의 라우트 세그먼트에 대하여 유니크한 UI이다. page.js 파일에서 리액트 컴포넌트를 default export하여 페이지를 정의할 수 있다. 네스티드 폴더로 라우트 세그먼트를 정의하고, page.js 파일로 해당 라우트에 접근 가능하도록 하는 것이다.

### 레이아웃

레이아웃은 여러 페이지에서 공유되는 UI이다. 네비게이션이 일어나는 중에도 레이아웃은 **상태를 유지**하고, 상호작용을 중단하지 않으며, 리렌더링되지 않는다. 그리고 레이아웃들 또한 네스팅될 수 있다.

레이아웃은 layout.js 파일에서 리액트 컴포넌트를 default export하여 정의할 수 있다. 레이아웃 컴포넌트는 children prop을 받아서 렌더링 중에 자식 레이아웃 및 자식 페이지에 populate한다.

> populate (programming) : 데이터를 특정 구조에 채워넣다. e.g. you can populate a react state with data from an API call.

> **good to know**
>
> - 최상단의 레이아웃은 root layout이라 불린다. root layout은 required이며, 앱 내 모든 페이지에서 공유된다.
> - 모든 라우트 세그먼트에서 고유의 레이아웃을 선택적으로 정의할 수 있다. 이 레이아웃은 해당 라우트 세그먼트에 네스팅되는 모든 페이지에 공유된다.
> - 레이아웃들은 기본적으로 네스팅된다. 각각의 부모 레이아웃은 children prop을 이용해 자식 레이아웃을 감싼다.
> - 레이아웃은 기본적으로 서버 컴포넌트이며, 클라이언트 컴포넌트로 설정할 수도 있다.
> - 레이아웃에서도 데이터를 패치할 수 있다.
> - 부모 레이아웃과 자식 간에 데이터를 전달할 수는 없다. 그러나 어떤 라우트에서 동일한 데이터를 여러 번 패치할 때, 리액트는 퍼포먼스에 영향을 주지 않으면서 자동적으로 중복된 API 리퀘스트를 제거한다. 이는 React가 내부적으로 데이터 요청을 추적하고, 동일한 요청이 여러 번 발생하면 한 번만 실제로 요청을 보내고 그 결과를 여러 곳에서 재사용하기 때문이다.
> - 레이아웃은 하위의 라우트 세그먼트에 접근할 수 없다. 모든 라우트 세그먼트에 접근하기 위해서는 useSelectedLayoutSegment 또는 useSelectedLayoutSegments를 이용해야 한다.
> - 레이아웃 생성에 .js, .jsx, .tsx 파일 확장자를 사용할 수 있다.
> - 하나의 폴더에서 각각 하나의 layout.js와 page.js가 정의될 수 있다. 여기서 레이아웃이 페이지를 감싼다.

### 루트 레이아웃 (Required)

루트 레이아웃은 앱 디렉터리 최상단에서 정의되며, 모든 라우트 세그먼트에 적용된다. 루트 레이아웃을 이용하면 서버에서 반환되는 초기 HTML을 변형할 수 있다.

> **good to know**
>
> - 앱 디렉터리는 반드시 하나의 루트 레이아웃을 가져야 한다.
> - 루트 레이아웃은 반드시 `<html>`, `<body>` 태그를 정의해야 한다. 넥스트가 그것들을 자동으로 생성하지 않기 때문이다.
>   `<title>`과 같은 `<head>` 요소들은 빌트인 SEO 지원을 통해 관리할 수 있다.
> - 라우트 그룹을 이용해 다수의 루트 레이아웃을 생성할 수도 있다.
> - 루트 레이아웃은 기본적으로 서버 컴포넌트이며, 클라이언트 컴포넌트로 설정할 수는 **없다**.

### 레이아웃의 네스팅

어떤 폴터 안에서 레이아웃(e.g. `app/dashboard/layout.js`)이 정의되면, 그것은 특정 라우트 세그먼트(e.g. `example.com/dashboard`)에 적용되며, 해당 라우트 세그먼트가 액티브할 때 레이이웃은 렌더링된다. 기본적으로 서로 연결되는 파일 계층 내의 레이아웃들은 서로 네스팅되는데, 이는 각 레이아웃이 children prop을 이용해 자식 레이아웃을 감싸는 것을 의미한다.

> **good to know**
>
> - 오직 루트 레이아웃에서만 `<html>`, `<body>` 태그들이 정의될 수 있다.

### 템플릿

템플릿은 자식 레이아웃 또는 자식 페이지를 네스팅한다는 점에서 레이아웃과 유사하다. 그러나 레이아웃이 여러 라우트 세그먼트들에 걸쳐서 보존되고 상태를 유지하는 것과 달리, 템플릿은 네비게이션 중에 자식 컴포넌트들에 대한 새로운 인스턴스를 생성한다. 이는 하나의 템플릿을 공유하는 라우트 간에서 유저가 이동할 때에도 해당 컴포넌트의 새로운 인스턴스가 마운트되고, DOM 요소들은 재생성되며, 상태들은 보존되지 않고, 이팩트는 재동기화된다는 것을 의미한다.

아래 상황들에서 템플릿은 레이아웃보다 강점을 가질 수 있다.

- useEffect, useState에 의지하는 특징을 갖는 경우.
- 프레임워크의 디폴트 동작을 변화시킬 필요가 있는 경우. e.g. 레이아웃의 서스펜스 바운더리는 레이아웃이 로드되는 단 한 번의 순간에만 fallback을 노출시키고, 페이지 이동 시에는 보여주지 않는 반면, 템플릿에서는 네비게이션이 이루어질 때마다 해당 fallback을 노출시킨다.

템플릿은 template.js 파일에서 리액트 컴포넌트를 default export하여 정의할 수 있는데, 이 컴포넌트는 하나의 children prop을 받아야 한다. 네스팅의 관점에서 보자면 템플릿은 레이아웃과 children 사이에서 렌더링된다.

```javascript
<Layout>
  {/* Note that the template is given a unique key. */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

### `<head>`의 수정

앱 디렉터리에서는 빌트인 SEO 지원을 이용해 `<title>`, `<meta>` 같은 `<head>` 요소들을 수정할 수 있다. 메타데이터는 layout.js 또는 page.js 파일에서 metadata 객체 또는 generateMetadata 함수를 export 함으로써 정의할 수 있다.

```javascript
// page.ts
import { Metadata } from “next”;

export const metadata: Metadata = {
  title: “Next.js”,
};

export default function Page() {
  return <></>;
}
```

> **good to know**
>
> - `<head>` 태그를 루트 레이아웃에 수동으로 추가해서는 **안 되며**, `<head>` 요소들의 스트리밍 또는 중복 제거와 같은 향상된 기능들을 자동으로 다루는 metadata API를 이용해야 한다.

## 링크와 네비게이션

넥스트에서 라우트 간의 리동을 구현하는 데에는 두 가지 방법이 있다. 하나는 `<Link>` 컴포넌트를 이용하는 것이고, 다른 하나는 `useRouter()` 훅을 이용하는 것이다.

### `<Link>` 컴포넌트

`<Link>` 컴포넌트는 빌트인 컴포넌트로서 HTML `<a>` 태그를 확장하여 프리패칭 및 라우트 간 클라이언트 사이드 네비게이션 기능을 제공한다. 이는 넥스트에서 라우트 간 이동을 구현하는 가장 일차적인 방법이다.

`<Link>` 컴포넌트는 next/link에서 임포트하고 href prop을 전달함으로써 사용 가능하다.

```javascript
import Link from “next/link”;

export default function Page() {
  return (
    <Link href="/dashboard">Dashboard</Link>
  );
}
```

### `<Link>` 컴포넌트 사용 예시

#### id로 스크롤하기

만약 네비게이션 시에 특정 id로 스크롤하고 싶다면 # 해시 링크를 URL에 포함하면 된다. 이는 `<Link>` 컴포넌트가 `<a>` 요소를 렌더링하기 때문에 가능하다.

#### 스크롤 복원 무효화

넥스트 앱 라우터의 디폴트 동작은 새로운 라우트의 최상단으로 스크롤하거나 앞뒤로 네비게이션 시에는 기존 스크롤 위치를 유지하는 것이다. 만약 이러한 동작을 막고 싶다면, `scroll={ false }`를 `<Link>` 컴포넌트에 전달하거나, `router.push()` 또는 `router.replace()`에 `{ scroll: false }`를 전달하면 된다.

### `useRouter()` 훅

`useRouter()` 훅은 프로그래밍적으로 라우트를 변경할 수 있도록 한다. `useRouter()` 훅은 한편 클라이언트 컴포넌트에서만 사용 가능하며, next/navigation에서 임포트한다.

> **recommendation**
>
> - `useRouter()`를 써야만 하는 경우가 아니라면 `<Link>` 컴포넌트를 사용하는 것이 좋다.

### 라우팅 및 네비게이션의 작동 원리

앱 라우터는 라우팅과 네비게이션을 구현하기 위해 하이브리드 접근법을 이용한다. 서버에서는 라우트 세그먼트 단위의 코드 분할이 자동적으로 이루어지며, 클라이언트에서는 넥스트가 라우트 세그먼트들을 프리패칭 및 캐싱한다. 이는 유저가 새로운 라우트로 네비게이션할 때 브라우저가 페이지를 리로드 하지 않고, 변화하는 라우트 세그먼트만이 리렌더링되어 유저 경험 및 퍼포먼스가 향상됨을 의미한다.

#### 프리패칭

프리패칭이란 유저가 방문하기 전에 백그라운드에서 한 라우트를 프리로드하는 방법이다.

넥스트는 두 가지 방법으로 라우트를 프리패치 한다.

1. `<Link>` 컴포넌트 : 라우트는 유저의 뷰포트에 보여지는 순간 자동으로 프리패치된다. 프리패칭은 페이지가 처음으로 로드되거나 스크롤을 통해 뷰에 나타날 때 일어난다.
2. `router.prefetch()` : `useRouter()` 훅을 이용하여 라우트를 프로그래밍적으로 프리패치할 수도 있다.

한편 `<Link>` 컴포넌트에 의한 프리패칭 동작은 정적 라우트와 동적 라우트에서 다르게 나타난다.

- 정적 라우트 : 전체 라우트가 프리패칭 및 캐싱된다.
- 동적 라우트 : loading.js 파일이 있기까지의 계층 상에서 공유되는 레이아웃들만이 30초 간 프리패칭 및 캐싱된다. 이는 모든 동적 라우트를 패칭하는 데 들 비용을 절약하는데, 이로써 유저들에게 보다 나은 시각적 피드백으로 로딩 상태를 보여줄 수 있다.

그리고 prefetch prop을 false로 전달함으로써 프리패칭을 방지할 수도 있다.

#### 캐싱

넥스트는 라우터 캐시라고 하는 매모리 내 클라이언트 사이드 캐시를 갖는다. 유저가 앱 내에서 네비게이션 할 때면 프리패칭된 라우트 세그먼트와 유저가 방문한 라우트의 리액트 서버 컴포넌트 페이로드가 캐시에 저장된다. 이는 네비게이션이 이루어질 때 서버에 새로운 리퀘스트를 보내는 것이 아니라 가능한 최대로 캐시를 재사용한다는 것을 의미하는데, 이는 리퀘스트 및 데이터 전송의 수를 줄여서 퍼포먼서를 향상시킨다.

#### 부분적 렌더링

부분적 렌더링이란 네비게이션 중에 변화하는 라우트 세그먼트만이 클라이언트에서 리렌더링되고 다른 모든 공유된 세그먼트들은 보존/재사용된다는 것을 의미한다. 부분적 렌더링이 없다면 네비게이션이 이루어질 때마다 전체 페이지가 서버에서 리렌더링 될 것이다. 변화하는 세그먼트만을 렌더링하는 것은 전송되는 데이터의 양 및 실행 시간을 줄여 퍼포먼스를 향상시킨다.

#### 소프트 네비게이션

디폴트로 브라우저는 페이지 간에 하드 네비게이션을 수행한다. 이는 브라우저가 페이지를 리로드하고 `useState` 훅 등에 의한 리액트 상태들과 유저의 스크롤 위치 또는 포커스된 요소 등과 같은 브라우저 상태들을 리셋시킨다는 것을 의미한다. 그러나 넥스트에서 앱 라우터는 소프트 네비게이션을 이용한다. 이는 리액트가 리액트 상태 및 브라우저 상태는 보존하면서, 변경된 세그먼트만을 렌더링하여, 전체 페이지가 리로되지 않도록 한다는 것을 의미한다.

#### 백워드/포워드 네비게이션

디폴트로 넥스트는 백워드/포워드 네비게이션 중 스크롤 위치를 유지시키며, 라우터 캐시의 라우트 세그먼트를 재사용한다.

## 라우트 그룹
