# 렌더링

[orginial content](https://nextjs.org/docs/app/building-your-application/rendering)

## 렌더링이란?

렌더링은 코드를 UI로 변환하는 작업이다. 리액트와 넥스트 이용하면, 코드를 부분적으로 서버나 클라이언트에서 렌더링할 수 있는 하이브리드 웹 어플리케이션을 생성할 수 있다. 아래에서는 이러한 렌더링의 각 종류에 대하여 해당 환경, 전략, 런타임의 차이점을 알아볼 것이다.

### 기본 개념

시작하기에 앞서 아래 세 가지 기본 웹 개념에 대해 이해하고 가면 좋을 것이다.

- 어플리케이션 코드를 실행할 _환경_(Environment)들: 서버와 클라이언트
- 유저가 어플리케이션에 방문하거나 상호작용할 때 촉발되는 _요청-응답 생명주기_(Request-Response Lifecycle)
- 서버 코드와 클라이언트 코드를 구분하는 _네트워크 바운더리_(Network Boundary)

### 렌더링 환경

웹 어플리케이션은 두 가지 환경, 즉 *클라이언트*와 *서버*에서 렌더링될 수 있다.

- 클라이언트는 서버에 요청을 보낼 수 있는, 유저 디바이스 내 브라우저를 나타낸다.
- 서버는, 어플리케이션 코드를 저장하고 클라이언트의 요청을 받아 적절한 응답을 보내는, 데이터 센터의 컴퓨터를 나타낸다.

과거 개발자들은 서버와 클라이언트의 코드를 작성하기 위해 서로 다른 언어와 프레임워크를 사용해야 했으나, 후에 리액트를 이용해 **동일한 언어**(자바스크립트)와 **동일한 프레임워크**(넥스트를 포함한 여러 프레임워크)를 사용할 수 있게 되었다.

#### 요청-응답 생명주기

넓게 보자면, 모든 웹사이트는 동일한 요청-응답 생명주기를 따른다.

1. 유저 액션 : 유저가 웹 어플리케이션과 상호작용한다. (ex) 링크 클릭, 폼 제출, URL 입력 등
2. HTTP 요청 : 클라이언트는 필요한 정보를 포함한 HTTP 요청을 서버에 보낸다.
3. 서버 : 서버는 요청을 처리하여 적절한 리소스와 함께 응답한다.
4. HTTP 응답 : 요청을 처리한 후, 서버는 클라이언트로 HTTP 응답을 보낸다.
5. 클라이언트 : 클라이언트는 리소스를 파싱하여 UI를 렌더링한다.
6. UI가 렌더링되면, 유저 상호작용이 가능해지고, 상호작용이 일어나면 위의 과정이 반복된다.

하이브리드 웹 어플리케이션을 만드는 데 주요한 부분은 생명주기 내의 작업을 어떻게 구분하고, 어디에 네트워크 바운더리를 둘 것인지 결정하는 데 있다.

#### 네트워크 바운더리

웹 개발에서 네트워크 바운더리란 서로 다른 환경을 구분하는 개념적인 선이다. 가령 클라이언트와 서버, 또는 서버와 데이터 저장소 사이의 선 말이다.

리액트로 개발할 때에는 클라이언트-서버 사이에서 가장 합리적인 네트워크 바운더리 위치를 선택해야 한다.

한편 이 작업은 보이지 않는 곳에서 두 개의 부분, 즉 **클라이언트 모듈 그래프**와 **서버 모듈 그래프**로 나누어진다. 서버 모듈 그래프는 서버에서 렌더링되는 모든 컴포넌트를 가지며, 클라이언트 모듈 그래프는 클라이언트에서 렌더링되는 모든 컴포넌트를 가진다.

이러한 바운더리는 리액트의 `“use client”` 디렉티브 컨벤션을 이용하여 정의할 수 있다.

### 하이브리드 어플리케이션 만들기

두 환경 사이에서, 어플리케이션 코드의 흐름을 _단방향_ 흐름으로 이해해보면 좋다. 달리 표현하면, 응답의 과정에서 어플리케이션 코드는 한 방향으로, 즉 서버에서 클라이언트로 흐른다.

클라이언트에서 서버에 접근할 필요가 있는 경우에는 동일한 요청을 재사용하는 것이 아니라 **새로운** 요청을 서버에 보낸다. 여기에 주목하면, 어디에서 컴포넌트를 렌더링해야 하고, 어디에 네트워크 바운더리를 두어야 하는지에 대해 쉽게 이해할 수 있을 것이다.

실제로 이러한 모델은 개발자들로 하여금 클라이언트로 결과물이 전달되어 유저 상호작용이 가능해지기 이전에 서버에서 실행해야 하는 것들에는 어떤 것들이 있을지 생각하도록 한다.

## 서버 컴포넌트

리액트 서버 컴포넌트는 UI가 서버에서 렌더링되고 캐싱될 수 있도록 한다. 서버 렌더링 전략에는 아래 세 가지 종류가 있다.

- 정적 렌더링(Static Rendering)
- 동적 렌더링(Dynamic Rendering)
- 스트리밍(Streaming)

### 서버 렌더링의 이점

서버에서 렌더링을 수행하면 아래와 같은 이점을 얻을 수 있다.

- 데이터 패칭 : 서버 컴포넌트는 데이터 소스와 더 가까이 있는 서버에서 데이터 패칭 로직을 수행할 수 있게 한다. 이는 렌더링에 필요한 데이터를 패칭하는 데 걸리는 시간을 줄임으로써, 그리고 클라이언트가 수행해야 할 요청의 수를 줄임으로써 퍼포먼스를 향상시킬 수 있다.
- 보안 : 서버 컴포넌트는 토큰이나 API 키와 같은 민감한 데이터나 로직을 클라리언트에 노출시킬 위험 없이 서버에서 관리하도록 한다.
- 캐싱 : 서버에서 렌더링함으로써 그 결과가 캐시에 저장되고, 후속 요청에서나 유저 간에 있어서 재사용될 수 있다.
- 퍼포먼스 : 서버 컴포넌트는 성능을 최적화할 추가적인 툴을 제공한다. 가령 클라이언트 컴포넌트로만 구성된 어떤 어플리케이션에 대하여, 유저 상호작용을 하지 않는 일부 UI를 서버 컴포넌트로 바꿈으로써 클라이언트-사이드의 자바스크립트 양을 줄일 수 있다.
- _초기 페이지 로드_(Initial Page Load) 및 _첫 번째 컨텐츠풀 페인트_(First Contentful Paint; FCP) : 서버에서 HTML을 생성하여 유저가 곧바로 페이지 내용을 볼 수 있게 한다. 이로 인해 클라이언트가 페이지를 렌더링하기 위해 자바스크립트를 다운로드, 파싱, 실행하기를 기다리지 않아도 페이지의 일부 내용을 볼 수 있다.
- 검색 엔진 최적화와 SNS 공유성 : 서버에서 렌더링된 HTML은 검색 엔진 봇이 페이지들을 인덱싱 하고, SNS 봇이 페이지의 프리뷰인 소셜 카드를 생성할 수 있게 한다.
- 스트리밍 : 서버 컴포넌트는 렌더링 작업을 청크들로 나누어, 그것들이 준비될 때 클라이언트로 스트리밍할 수 있도록 한다.

### 넥스트에서 서버 컴포넌트 사용하기

넥스트는 디폴트로 서버 컴포넌트를 사용한다. 따라서 개발자는 추가적인 설정 없이 자동으로 서버 렌더링을 구현할 수 있고, 필요한 경우에는 클라이언트 컴포넌트를 사용할 수도 있다.

### 서버 컴포넌트는 어떻게 렌더링되는가?

서버에서 넥스트는 리액트 API들을 이용하여 렌더링을 조율한다. 렌더링 작업은 각각의 라우트 세그먼트와 서스펜스 바운더리에 의해 다수의 청크들로 나누어진다.

각각의 청크는 아래 두 스텝에 걸쳐 렌더링된다.

1. 리액트는 서버 컴포넌트를 **리액트 서버 컴포넌트 페이로드**(React Server Component Payload; RSC Payload)라고 하는 특별한 데이터 형태로 렌더링한다.
2. 넥스트는 RSC 페이로드와 클라이언트 컴포넌트 자바스크립트 인스트럭션을 사용하여 서버에서 **HTML**을 렌더링한다.

그러면 클라이언트에서는,

1. HTML은 곧바로 해당 라우트의 상호작용하지 않는 프리뷰를 보여주는 데 사용된다. 이는 오직 초기 페이지 로드에만 한정된다.
2. RSC 페이로드는 클라이언트 컴포넌트와 서버 컴포넌트의 트리들을 조정하고 DOM을 업데이트하는 데 이용된다.
3. 자바스크립트 인스트럭션은 클라이언트 컴포넌트를 하이드레이트하여 어플리케이션에 상호작용성을 더하는 데 이용된다.

> 리액트 서버 컴포넌트(RSC) 페이로드란?
>
> RSC 페이로드는 렌더링된 리액트 서버 컴포넌트들의 트리를 나타내는 압축된 이진수 형태로, 리액트가 클라이언트에서 브라우저 DOM을 업데이트 하는 데 사용된다. RSC 페이로드는 아래의 것들을 포함한다.
>
> - 서버 컴포넌트의 렌더링 결과물
> - 클라이언트 컴포넌트가 렌더링되어야 할 영역의 플레이스홀더와 해당 자바스크립트 파일에 대한 참조
> - 서버 컴포넌트에서 클라이언트 컴포넌트로 전달되는 props

### 서버 렌더링 전략

#### 정적 렌더링 (디폴트)

정적 렌더링에서, 라우트는 **빌드 타임**에, 또는 _데이터 재검증_(revalidation) 후 백그라운드에서 렌더링된다. 이때 렌더링 결과는 캐시에 저장되고, 컨텐트 딜리버리 네트워크(CDN)로 푸시된다. 이러한 최적화로 인해 유저들 그리고 서버 요청들은 렌더링 작업 결과물을 공유할 수 있다.

정적 렌더링은, 정적인 블로그 포스트 또는 상품 페이지의 경우와 같이, 라우트가 각 유저에게 개인화되지 않은 데이터를 사용하여 그 내용을 빌드 타임에 결정할 수 있는 경우에 유용하다.

#### 동적 렌더링

동적 렌더링에서, 라우트는 각 유저의 매 **요청 시점**에 렌더링된다.

동적 렌더링은, 쿠키나 URL 검색 파라미터의 경우와 같이, 라우트가 유저에게 개인화된 데이터를 가지거나 또는 요청 시점에만 그 값이 결정될 수 있는 정보를 가질 때에 유용하다.

> 캐싱된 데이터를 갖는 동적 라우트
>
> 대부분의 웹사이트에서 라우트는 완전히 정적이지도, 완전히 동적이지도 않으며, 오히려 둘 사이의 스펙트럼에 가깝다. 가령 어떤 이커머스 페이지는 일정 간격으로 재검증되는 캐싱된 상품 데이터를 가지면서도, 캐싱되지 않는, 개인화된 소비자 데이터를 동시에 가질 수 있다.
> 넥스트에서는 동적으로 렌더링된 라우트가 가능하며, 이는 캐싱되는 데이터와 캐싱되지 않는 데이터 모두를 가진다. 이는 RSC 페이로드와 데이터가 따로따로 캐싱되기 때문에 가능하다. 이로 인해 모든 데이터를 요청 시점에 패칭하는 것과 같은 퍼포먼스 악영향에 대한 걱정 없이 동적 렌더링을 선택할 수 있게 된다.

##### 동적 렌더링으로 전환하기

렌더링 과정에서 동적 함수나 캐싱되지 않은 데이터에 대한 요청이 발견되면, 넥스트는 라우트 전체를 동적으로 렌더링하도록 전환할 것이다. 아래 표는 동적 함수와 데이터 캐싱이 라우트의 정적/동적 렌더링 여부에 어떻게 영향을 끼치는지를 보여준다.

| 동적 함수 | 데이터     | 라우트      |
| --------- | ---------- | ----------- |
| no        | cached     | 정적 렌더링 |
| yes       | cached     | 동적 렌더링 |
| no        | not cached | 동적 렌더링 |
| yes       | not cached | 동적 렌더링 |

넥스트가 라우트의 형태 및 사용되는 API에 기반하여 각각의 라우트에 대한 최고의 렌더링 전략을 자동으로 선택할 것이므로, 개발자가 직접 정적/동적 렌더링 중 하나를 선택할 필요는 없다. 대신에 개발자는, 언제 특정 데이터를 캐싱 또는 재검증할 것인지, 그리고 어떤 경우에는 UI의 조각들을 스트리밍할 것인지를 선택한다.

##### 동적 함수

동적 함수는, 유저의 쿠키나 현재 요청의 헤더, URL의 검색 파라미터 등과 같이, 요청 시점에만 알려질 수 있는 정보에 의지한다. 넥스트에서 이러한 동적 함수들에는 아래와 같은 것들이 있다.

- `cookies()`와 `headers()` : 서버 컴포넌트에서 이들을 이용하면 라우트 전체가 요청 시점에 동적으로 렌더링되도록 한다.
- `searchParams` : `searchParams` prop을 페이지에서 사용하면 페이지는 요청 시점에 동적으로 렌더링된다.

#### 스트리밍

스트리밍은 서버로부터의 UI를 점진적으로 렌더링할 수 있도록 한다. 작업은 청크들로 나누어지고, 준비되는 순간 클라이언트로 스트리밍된다. 이로써 유저는, 전체 컨텐츠가 모두 렌더링되기 이전에, 페이지의 일부를 즉각적으로 볼 수 있게 된다.

스트리밍은 넥스트 앱 라우터에 디폴트로 내장되어 있다. 이는 초기 페이지 로딩 성능에 더불어, 속도가 느려 전체 라우트 렌더링을 차단할 수도 있을 데이터 패치에 의존하는 UI의 성능까지 향상시킬 수 있다.

`loading.js`나 리액트 서스펜스를 갖는 UI 컴포넌트를 이용하여 라우트 세그먼트의 스트리밍을 시작해볼 수 있다.